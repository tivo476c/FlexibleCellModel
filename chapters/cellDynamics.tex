\section{DF model and dynamics}\label{dynamics}

%TODO find right references for non confluent and deformable cell models
Several cell modelling approaches have already been discussed in the introduction. 
In the following section, we establish the specific model and dynamical framework used in this thesis. 
We focus on a non-confluent cell setting, as in~\cite{Boromand2018}, where free space in between cells is permitted.
Moreover, we require cells to be deformable, following ideas from~\cite{Boromand2018, Fletcher14, wenzel2021, Happel2023}. \\
Therefore, we choose a vertex based cell approach, like in~\cite{Fletcher14, Boromand2018}, in which each cell is represented by a polygon defined by its vertices.
The DF cell model, originally introduced in my Bachelor's thesis~\cite{Vogel2023}, satisfies these properties. 
This chapter revisits this model and its dynamical formulation. 
Over the course of this thesis, the dynamics and implementation of the original DF model were refined and extended in several ways.

\subsection{DF cell model}\label{model}
% give definition for DF model, before that explain all needed math. terms 

We are considering cells in the two-dimensional space $\R^2$. 
Here, cells are considered to be polygons. 

\begin{definition} \textbf{Polygon} \\
	A polygon is a closed geometric figure in $\R^2$, constructed by joining a finite number of straight line segments end to end. 
	It can be described by a sequence of its vertices $(\vec{v}_1, \ldots, \vec{v}_N)$.
	The following properties characterise a polygon:
	\begin{enumerate}
	% \begin{enumerate}
		\item A polygon is \textbf{simple} if no two line segments cross each other. 
		\item A polygon has a \textbf{positive orientation} if the vertices are ordered counterclockwise.
		\item A polygon has a \textbf{negative orientation} if the vertices are ordered clockwise.
	\end{enumerate}
\end{definition}

Having established this definition, we are now ready to define our cell model.

\begin{definition} \textbf{Discrete form (DF)} \label{def:DF}  \\
	A cell in its discrete form (\textbf{DF}) is given by an ordered sequence of its vertices $C = (\vec{v}_1, \ldots , \vec{v}_N)$ if the resulting polygon when connecting every vertex with its neighbours and $\vec{v}_1$ with $\vec{v}_N$  is simple and positively orientated. 
	We set $\vec{v}_{N+1} = \vec{v}_{1}$ and $\vec{v}_{0} = \vec{v}_{N}$ to enable periodic indexing, which simplifies the computation of the upcoming forces a lot.
\end{definition}

In this thesis, DF cells may also be called discrete cells. 
In our model, the cell vertices are denoted by $\vec{v}$. 
Thus, the character $v$ refers to vertex positions and not to velocity.
The term velocity is not used throughout this thesis as vertex dynamics are entirely given by the upcoming forces and a cell wise computed Brownian motion. \\


The next step is to describe the setup of a DF simulation. 
\begin{definition} \textbf{DF simulation} \label{def:DF-Sim}  \\
	A DF simulation considers $N_C \in \N$ cells. 
	Each cell has the same amount of $N_V \in \N$ vertices.
	The notation of cell $i$ is given by 
	\begin{center}
		$C^{i} = (\vec{v}^{\:i}_1, \ldots, \vec{v}^{\:i}_{N_V}), \quad 1 \leq i \leq N_{C}$. 
	\end{center}

	The complete set of all cells is represented by 
	\begin{center}
		$\vec{C} = (C^{1}, \ldots, C^{N_C})$,
	\end{center}
	which also contains all vertices from all cells.

	The simulation's dynamics are defined on all cell vertices via the stochastic differential equation (SDE):
	\begin{center}
		$ \dequ \vec{v}^{\:i}_j(\vec{C}(t), t) = \F^i_j(\vec{C}(t)) \, \dequ t + \sqrt{2 D} \, \dequ \vec{B}_i(t), \quad 1 \leq i \leq N_{C}, \: 1 \leq j \leq N_{V}$. 
	\end{center}
	where $\F^i_j$ describes the total interaction force on vertex $\vec{v}^{\:i}_j$ caused by the current cell system $\vec{C}$ and $\sqrt{2 D} \dequ \vec{B}_i(t)$ models the two-dimensional standard Brownian motion of cell $i$ with diffusion coefficient $D$.  
	Note, that all vertices of cell $i$ perform the same Brownian motion such that the whole cell $i$ moves in the direction of $\dequ \vec{B}_i(t)$. \\

	The simulation domain is always a square around the origin that is defined by $L > 0$ via 
	\begin{center}
		$
		\Omega_L = [-L, L]^2.
		$
	\end{center} 
\end{definition}

We characterise the interaction force $\F$ as the sum of gradient flows of energies. 
A gradient flow describes how a system changes over time in a way that always reduces a given energy $E(\vec{C})$.
To obtain the gradient flow of this energy on vertex $\vec{v}$, we must add the term $-\nabla_{\vec{v}} E(\vec{C})$ to $\F$.
Since all our energy terms are positive, the lowest possible value is zero.  
So, the gradient flow moves the system step by step toward this minimum, always trying to decrease the energy until, ideally, it reaches zero. 
This is how we guide the motion of our cells: by letting them follow the gradient flow of each energy so that their shapes and vertex positions gradually adjust to reduce the total energy. \\
In~\cite{Vogel2023}, the area, edge, interior angle, and overlap energies were introduced.
The first three energies are responsible for maintaining the shape of each cell. 
All of these forces act on each cell in a vacuum based only on its own current cell shape. \\
Unlike in~\cite{Vogel2023}, where each cell was assigned an individual desired state, we now assume a common desired state for all cells. This simplification allows for a more controlled analysis of the system's deformability and its influence on the collective dynamics.
We assume that all cells are initially given in their desired states in order to prevent system instabilities right from the beginning. \\
Additionally, we introduce slight modifications to the energy formulation: rather than being defined locally on vertices or edges, the energies are now defined over entire cells. 
This adjustment provides a more coherent basis for deriving cell-level forces and ensures consistency with the global dynamic framework introduced in this study. \\
Interactions between different cells just arise from the overlap force, which acts to resolve overlaps and to prevent cell interpenetration. 
In the process of resolving overlaps, the shape of the cells will change.  
Once the overlap is resolved, the first three forces act to restore the cell's original shape. \\
The central question we aim to investigate in this thesis is how the deformability of individual cells influences the overall diffusivity of the cell system.
But first, let us introduce each of the mentioned forces. \\
We define our energies as
\[
	E_k(x) = \tfrac{1}{k} |x_{\text{current}} - x_{\text{desired}}|^k, 
\]
where $k \in \N$ is a positive integer parameter specific to each energy term. 
When considering the gradient flow of this energy, we obtain a force of the form 
\[
	- \nabla E_k(x) = - |x_{\text{current}} - x_{\text{desired}}|^{k-1} \nabla x_{\text{current}}.
\]
Different choices of $k$ give rise to qualitatively distinct force laws in the corresponding gradient flow. 
For $k=1$, the force is independent of the magnitude of the deviation $|x_{\text{current}} - x_{\text{desired}}|$, as that term has a power of zero after applying the gradient.
This makes it suitable for modelling strongly corrective forces that react immediately to small deviations, such as our overlap degeneration force. 
In contrast, for $k=2$ the force scales linearly with the deviation, yielding a weaker response near the desired state and a stronger response for larger discrepancies. 
This behaviour is well suited for modelling shape preserving energies. \\
In order to compute the forces arising from these energy functions, we require the gradient $\nabla E$. 
This leads us to compute derivatives of the form 
\[ 
	\frac{\dequ}{\dequ x} |x|^k. 
\]
While $|x|^k$ is not classically differentiable at $x=0$, it is weakly differentiable for all $k \in \N$.
There exists a locally integrable function 
\[ 
	x \mapsto k \sgn(x)|x|^{k-1} \in L^1_{loc}(\R),
\] 
such that for all $\phi \in C_C^{\infty}(\R)$:
\begin{align*}
	\int_{\R} |x|^k \phi'(x) \: \dequ x  
	&= \int_{\R_{+}} x^k \phi'(x) \: \dequ x + \int_{\R_{-}} (-x)^k \phi'(x) \: \dequ x \\
	&= [x^k \phi(x)]_{0}^{\infty} - \int_{\R_{+}} k x^{k-1} \phi(x) \: \dequ x  \\
	& \quad + [(-x)^k \phi(x)]_{0}^{\infty} - \int_{\R_{-}} k (-x)^{k-1} \phi(x) \: \dequ x \\
	&= - \int_{\R_+} k x^{k-1} \phi(x) \: \dequ x - \int_{\R_-} k (-x)^{k-1} \phi(x) \: \dequ x \\
	&= - \int_{\R} k \sgn(x)|x|^{k-1} \phi(x) \: \dequ x.
\end{align*}
Thus, $x \mapsto k \sgn(x)|x|^{k-1}$ is the weak derivative of $x \mapsto |x|^k$. 
We will use this weak derivative for all of our force computations. 

\subsection{Area force}
The area force is designed to maintain each cell's area close to a preferred target value. 
In order to compute a cells area, which is the area of a positively orientated polygon, we can use the Shoelace formula from~\cite{Shoelace2014}. 

\begin{proposition}  \textbf{Shoelace formula for DF cells} \label{prop:Shoelace}\\ 
	Let $C = (\vec{v}_1, \ldots, \vec{v}_N)$ be a DF cell with $\vec{v}_j = (v_j^{x}, v_j^{y})^T$ for $j=1,\ldots,N$.
	We determine the area $A_C$ of $C$ by applying the Shoelace formula
	\begin{center}
		$A_C = \frac{1}{2}\sum\limits_{j = 1}^{N} (v_j^{x} v_{j+1}^{y} - v_{j+1}^{x} v_j^{y})$,
	\end{center} 
	where $\vec{v}_{N + 1} = \vec{v}_1$. \\
	Proof. 	\\
	An illustration supporting the proof is provided in Figure~\ref{fig:shoelace}, which is where the idea of the proof comes from. 
	Without loss of generality, we may assume that all coordinates are positive.
	If this is not initially the case, the entire polygon can be translated into the positive quadrant without affecting its area. \\
	For each $1 \leq j \leq N$ the edge between the vertices $\vec{v}_j$ and $\vec{v}_{j+1}$ is associated with the area $T_j$ of the trapeze that arises when connecting the line segment vertically with the $x$-axis. 
	The signed trapeze area of $T_j$ can be computed with 
	\begin{center}
		$T_j = \frac{1}{2} (v_j^{y} + v_{j+1}^{y})(v_j^{x} - v_{j+1}^{x})$.
	\end{center}
	The area $T_j$ has a positive sign if $v_j^{x} \geq v_{j+1}^{x}$ (green arrow in Figure \ref{fig:shoelace}) and a negative sign otherwise (red arrow). 
	As depicted in the figure, the negatively signed areas precisely cancel the excess portions that would result from summing only the positively signed trapezoids.
	Thus the total polygon's area is equal to the sum of all trapezes
	\begin{center}
		$A_C = \sum\limits_{j = 1}^{N} T_j = \frac{1}{2} \sum\limits_{j = 1}^{N} (v_j^{y} + v_{j+1}^{y})(v_j^{x} - v_{j+1}^{x}) = \frac{1}{2}\sum\limits_{j = 1}^{N} (v_j^{x} v_{j+1}^{y} - v_{j+1}^{x} v_j^{y}) $.
	\end{center} 
\qed
\end{proposition}


\begin{figure}
	\begin{center}
		\includegraphics[width=0.7\textwidth]{bachelors-thesis/shoelace_new.png}
		\caption{
			This figure shows a geometrical interpretation of the shoelace formula.
			The green arrows, which point from right to left, represent positive trapezoidal areas that contribute positively to the total area of the polygon.
			In contrast, the red arrows point from left to right and represent negative areas that are subtracted in the computation.
			The vertical black lines divide the plot into subregions.
			Within each subregion, green arrows are counted with plus signs and red arrows with minus signs.
			We observe that the subregions lying outside the polygon contain an equal number of plus and minus signs, indicating that their net contribution to the area is zero.
			In contrast, the subregions inside the polygon always have one more plus sign than minus signs, meaning their area is counted exactly once in the total.
			Overall, this illustrates that the method correctly computes the area of the polygon.
			Source:~\cite{ShoelaceFigure2022}}
		\label{fig:shoelace}
	\end{center}
\end{figure}
	
% \FloatBarrier   % prevents floats from passing this point


With the Shoelace formula we are able to easily compute all cell areas at all times in the simulation. 
This enables us to implement the gradient flow over the area energy. 

\begin{definition} \textbf{Area energy} \\
	The energy $A_k: (\R^2)^{N_V} \rightarrow \R_{\geq 0}$ for $k \in \N$, used to keep the cells at a constant volume, reads 
	\begin{align}
		A_k(C) = \tfrac{1}{k} |A_{C} - A_d|^k, \label{eq:areaEnergy} 
	\end{align}
	where $A_d$ is the desired cell area of all cells and $A_{C}$ is the current area of cell $C$. 
\end{definition}

To maintain the cell area during the simulation, we evaluate the gradient flow of the area energy which indicates the direction of motion for each vertex for preserving the cell area.
\begin{figure}[t!]
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\textwidth]{forces/area1/t0.png} &
        \includegraphics[width=0.45\textwidth]{forces/area1/t1.png} \\
        \includegraphics[width=0.45\textwidth]{forces/area1/t2.png} &
        \includegraphics[width=0.45\textwidth]{forces/area1/t5.png} \\
    \end{tabular}
    \caption{The top four plots show the evolution of a DF cell influenced solely by the area force, with $k=2$ applied to the vertices and a force scaling of $4\times 10^{8}$, at times $t \in \{0, 1\times 10^{-5}, 2\times 10^{-5}, 5\times 10^{-5}\}$.
	Thus, we have $\frac{\dequ \vec{v}}{\dequ t} = - 4\times 10^{8} \,\nabla_{\vec{v}} A_2(C)$ for all vertices.
	The initial cell area is $A_C = 1\times 10^{-5}$, while the desired cell area is set to $6.5\times 10^{-5}$.
	We deliberately chose an irregular cell shape, since small vertical changes to the vertices lead to large changes in area.
	Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-areaForce.gif}{\textit{here}} to view the corresponding animation (GIF).
	The area force successfully restores the desired cell area after 5 time steps. This reduction in energy is likewise reflected in Figure~\ref{fig:areaEnergyDiagram}.
	}
	\label{fig:areaForce}    
\end{figure}
\FloatBarrier   % prevents floats from passing this point
\vspace{3cm}
\text{ }


\begin{figure}[t!]
    \centering
	\includegraphics[width=0.7\textwidth]{forces/area1/energies-show-areaForce.png} 
    \caption{The area force successfully restores the desired cell area after 5 time steps as this energy diagram shows.}
	\label{fig:areaEnergyDiagram}    
\end{figure}

\vspace{3cm}

\begin{proposition} \textbf{Area force} \label{force:area}\\
	The area force $F_{k}^{(A)}: (\R^2)^{N_V} \rightarrow (\R^2)^{N_V}$ that gets applied on cell $C$ is given by  
	\begin{align*}
		F_{k}^{(A)}(C) 
		= - (\nabla_{\vec{v}_1} A_k(C), \ldots, \nabla_{\vec{v}_{N_V}} A_k(C))^T,
	\end{align*}
	where the gradient $\nabla_{\vec{v}_j} A_k(C)$ with respect to $\vec{v}_j = (v_{j}^{x}, v_{j}^{y})^T$ is given by 
	\begin{align}
		\nabla_{\vec{v}_j} A_k(C) = \dfrac{1}{2} \sgn(A_{C} - A_d) |A_{C} - A_d|^{k-1} \begin{pmatrix} v_{j+1}^{y} - v_{j-1}^{y} \\[0.5em]  v_{j-1}^{x} - v_{j+1}^{x} \end{pmatrix},
		\label{gradient:area}
	\end{align}
	for all $1 \leq j \leq N_V$.\\

	Proof.\\
	Choose $1 \leq j \leq N_V$.  
 
	\begin{align*}
		\nabla_{\vec{v}_j} A_k(C) &= \tfrac{1}{k} \nabla_{\vec{v}_j} | A_{C} - A_d |^k  \\ 
		&= \sgn(A_{C} - A_d) | A_{C} - A_d |^{k-1} \nabla_{\vec{v}_j} (A_{C} - A_d) \\
		&= \sgn(A_{C} - A_d) | A_{C} - A_d |^{k-1} \nabla_{\vec{v}_j} A_{C} \\
		&= \sgn(A_{C} - A_d) | A_{C} - A_d |^{k-1} \nabla_{\vec{v}_j} \left(\frac{1}{2} \sum\limits_{k = 1}^{N} (v_k^{x} v_{k+1}^{y} - v_{k+1}^{x} v_k^{y})\right) \\[0.5em]  
		&= \frac{1}{2} \sgn(A_{C} - A_d) | A_{C} - A_d |^{k-1} \begin{pmatrix}
				\partial_{v_j^{x}} (v_j^{x} v_{j+1}^{y} - v_j^{x} v_{j-1}^{y})  \\[0.5em]
				\partial_{v_j^{y}} (v_{j-1}^{x} v_j^{y} - v_{j+1}^{x} v_j^{y})
			\end{pmatrix} \\[0.5em] 
		&= \frac{1}{2} \sgn(A_{C} - A_d) | A_{C} - A_d |^{k-1} \begin{pmatrix}
				v_{j+1}^{y} - v_{j-1}^{y}  \\
				v_{j-1}^{x}  - v_{j+1}^{x} 
			\end{pmatrix}.
	\end{align*}

	Remember that $A_d$ is just an independent constant. 
	\qed
\end{proposition}

It is also valid to write $F_{j}^{(A)}(\vec{C})$ instead of $F_{j}^{(A)}(C)$, since $C$ is included in $\vec{C}$. 
Figure~\ref{fig:areaForce} illustrates how the area force acts on a cell to either expand or contract it toward the desired target area.\\ 


\subsection{Edge force}
The next force we would like to model is the edge force. 
It acts on the cells' edges and aims to maintain their lengths.
We define the edge $j$ to be between $\vec{v}_j$ and $\vec{v}_{j+1}$ and use the operator 
\begin{center}
	$
	E^j_C = \norm[\vec{v}_j - \vec{v}_{j+1}], 
	$
\end{center}
to compute the length of the edge. 

The according energy for this edge is:
\begin{definition} \textbf{Edge energy} \\
	The energy $E_k: (\R^2)^{N_V} \rightarrow \R_{\geq 0}$, used to keep the edges at a constant length, reads 
	\begin{align}
		E_k(C) =  \sum\limits_{j=1}^{N_V} \tfrac{1}{k} |E^j_{C} - E^{j}_d|^k, \label{eq:edgeEnergy} 
	\end{align}
	where $E^j_{C}$ is the current edge length and $E^{j}_d$ is the desired edge length of edge $j$. 
\end{definition}

Since each vertex $\vec{v}_j$ influences exactly the edge lengths of the edges $e_{j}$ and $e_{j-1}$, we get the total edge force on $\vec{v}_j$ with: 
An isolated application of the edge force can be seen in Figure~\ref{fig:edgeForce}.  

\begin{proposition} \textbf{Edge force} \label{prop:edgeforce} \\
	The edge force $F_{k}^{(E)}: (\R^2)^{N_V} \rightarrow (\R^2)^{N_V}$ that gets applied on cell $C$ is given by  
	\begin{align*}
		F_{k}^{(E)}(C) 
		= - (\nabla_{\vec{v}_1} E_k(C), \ldots, \nabla_{\vec{v}_{N_V}} E_k(C))^T,
	\end{align*}
	where the gradient $\nabla_{\vec{v}_j} E_k(C)$ with respect to $\vec{v}_j = (v_{j}^{x}, v_{j}^{y})^T$ is given by 
	\begin{align}
		\begin{split}
			\nabla_{\vec{v}_j} E_k(C) &= \sgn(E^{j-1}_{C}- E_d^{j-1}) \dfrac{|E^{j-1}_{C}- E_d^{j-1}|^{k-1}}{E^{j-1}_{C}}  
			\begin{pmatrix} v_{j}^{x} - v_{j-1}^{x} \\[0.5em]  v_{j}^{y} - v_{j-1}^{y}  \end{pmatrix} \\[0.5em]
			&+ \sgn(E^j_{C} - E_d^{j}) \dfrac{|E^j_{C} - E_d^{j}|^{k-1}}{E^j_{C}}  
			\begin{pmatrix} v_{j}^{x} - v_{j+1}^{x} \\[0.5em]  v_{j}^{y} - v_{j+1}^{y} \end{pmatrix},
		\end{split}
		\label{gradient:edge}
	\end{align}
	for all $1 \leq j \leq N_V$.\\

	Proof. %of Proposition \ref{prop:edgeforce}. \\
	We consider
	\begin{align*}
		\nabla_{\vec{v}_{j}} E_k(C) &= \nabla_{\vec{v}_{j}} \sum\limits_{j=1}^{N_V} \tfrac{1}{k} |E^j_{C} - E^{j}_d|^k \\
		&= \tfrac{1}{k} \nabla_{\vec{v}_{j}} |E^{j-1}_{C} - E^{j-1}_d|^k + \tfrac{1}{k}\nabla_{\vec{v}_{j}} |E^j_{C} - E^{j}_d|^k.
	\end{align*}

	For the first summand, we can compute 
	\begin{align*}
		\tfrac{1}{k} \nabla_{\vec{v}_{j}} |E^{j-1}_{C} - E^{j-1}_d|^k 
		&= \sgn(E^{j-1}_C - E^{j-1}_d) |E^{j-1}_C - E^{j-1}_d|^{k-1} \nabla_{\vec{v}_j} (E^{j-1}_C - E^{j-1}_d) \\
		&= \sgn(E^{j-1}_C - E^{j-1}_d) |E^{j-1}_C - E^{j-1}_d|^{k-1} \nabla_{\vec{v}_j} E^{j-1}_C \\
		&= \sgn(E^{j-1}_C - E^{j-1}_d) |E^{j-1}_C - E^{j-1}_d|^{k-1} \cdot\\
		& \hspace{1cm} \nabla_{\vec{v}_j} [(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2]^{\frac{1}{2}}\\
		&= \sgn(E^{j-1}_C - E^{j-1}_d) |E^{j-1}_C - E^{j-1}_d|^{k-1} \cdot    \\
		& \hspace{1cm} \left(\frac{1}{2 E^{j-1}_C} \nabla_{\vec{v}_j} [(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2]\right) \\[0.5em] 
		&= \sgn(E^{j-1}_C - E^{j-1}_d) |E^{j-1}_C - E^{j-1}_d|^{k-1} \cdot\\
		& \hspace{1cm} \nabla_{\vec{v}_j} [(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2]^{\frac{1}{2}}\\
		&= \sgn(E^{j-1}_C - E^{j-1}_d) |E^{j-1}_C - E^{j-1}_d|^{k-1} \cdot    \\
		& \hspace{1cm} \left(\frac{1}{2 E^{j-1}_C} \nabla_{\vec{v}_j} [(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2]\right) \\[0.5em] 
		&= \sgn(E^{j-1}_C - E^{j-1}_d) \frac{|E^{j-1}_C - E^{j-1}_d|^{k-1}}{2 E^{j-1}_C} \begin{pmatrix}
			\partial_{v_{j}^{x}} (v_{j-1}^{x} - v_{j}^{x})^2 \\[0.5em]
			\partial_{v_{j}^{y}} (v_{j-1}^{y} - v_{j}^{y})^2
		\end{pmatrix} \\[0.5em]
		&= \sgn(E^{j-1}_C - E^{j-1}_d) \frac{|E^{j-1}_C - E^{j-1}_d|^{k-1}}{2 E^{j-1}_C} \begin{pmatrix}
			 -2(v_{j-1}^{x} - v_{j}^{x}) \\[0.5em]
			 -2(v_{j-1}^{y} - v_{j}^{y})
		\end{pmatrix} \\[0.5em] 
		&= \sgn(E^{j-1}_C - E^{j-1}_d) \frac{ |E^{j-1}_C - E^{j-1}_d|^{k-1}}{E^{j-1}_C} \begin{pmatrix}
				v_{j}^{x} - v_{j-1}^{x} \\[0.5em]
				v_{j}^{y} - v_{j-1}^{y}
		\end{pmatrix}.
	\end{align*}

	For the second summand, we get:
	\begin{align*}
		\tfrac{1}{k} \nabla_{\vec{v}_{j}} |E^{j}_{C} - E^{j}_d|^k 
		&= \sgn(E^{j}_C - E^{j}_d) |E^{j}_C - E^{j}_d|^{k-1} \nabla_{\vec{v}_j} E^{j}_C \\
		&= \sgn(E^{j}_C - E^{j}_d) |E^{j}_C - E^{j}_d|^{k-1} \cdot   \\
		& \hspace{1cm} \left(\frac{1}{2 E^{j}_C} \nabla_{\vec{v}_j} [(v_{j}^{x} - v_{j+1}^{x})^2 + (v_{j}^{y} - v_{j+1}^{y})^2]\right) \\[0.5em] 
		&= \sgn(E^{j}_C - E^{j}_d) |E^{j}_C - E^{j}_d|^{k-1} \cdot   \\
		& \hspace{1cm} \left(\frac{1}{2 E^{j}_C} \nabla_{\vec{v}_j} [(v_{j}^{x} - v_{j+1}^{x})^2 + (v_{j}^{y} - v_{j+1}^{y})^2]\right) \\[0.5em] 
		&= \sgn(E^{j}_C - E^{j}_d) \frac{|E^{j}_C - E^{j}_d|^{k-1}}{2 E^{j}_C} \begin{pmatrix}
			\partial_{v_{j}^{x}} (v_{j}^{x} - v_{j+1}^{x})^2 \\[0.5em]
			\partial_{v_{j}^{y}} (v_{j}^{y} - v_{j+1}^{y})^2
		\end{pmatrix} \\[0.5em]
	\end{align*}
		
	\begin{align*}
		\hspace{2.5cm}&= \sgn(E^{j}_C - E^{j}_d) \frac{|E^{j}_C - E^{j}_d|^{k-1}}{2 E^{j}_C} \begin{pmatrix}
			2(v_{j}^{x} - v_{j+1}^{x}) \\[0.5em]
			2(v_{j}^{y} - v_{j+1}^{y})
		\end{pmatrix} \\[0.5em]
		&= \sgn(E^{j}_C - E^{j}_d) \frac{ |E^{j}_C - E^{j}_d|^{k-1}}{E^{j}_C} \begin{pmatrix}
				v_{j}^{x} - v_{j+1}^{x} \\[0.5em]
				v_{j}^{y} - v_{j+1}^{y}
		\end{pmatrix}.
	\end{align*}
	Equation~\eqref{gradient:edge} arises when adding both summands. \\
	\qed  
\end{proposition}

\FloatBarrier

\begin{figure}[t!]
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\textwidth]{forces/edge1/t0.png} &
        \includegraphics[width=0.45\textwidth]{forces/edge1/t1.png} \\
        \includegraphics[width=0.45\textwidth]{forces/edge1/t2.png} &
        \includegraphics[width=0.45\textwidth]{forces/edge1/t5.png} \\
    \end{tabular}
    \caption{The top figures illustrate the evolution of a DF cell governed exclusively by the edge force, with $k=2$ applied to the vertices and a force scaling of $3\times 10^{4}$, at times $t \in \{0, 1\times 10^{-5}, 2\times 10^{-5}, 5\times 10^{-5}\}$.
		Accordingly, we have $\frac{\dequ \vec{v}}{\dequ t} = - 3\times 10^{4}\, \nabla_{\vec{v}} E_2(C)$ for all vertices.
		The initial edge length of the top edge is $E_C^2 = 1\times 10^{-3}$, while the desired edge lengths are all set to $5\times 10^{-3}$.
		Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-edgeForce.gif}{\textit{here}} to view the associated animation (GIF).
		The edge force nearly restores the desired edge lengths after 5 time steps, which can also be observed in Figure~\ref{fig:edgeEnergyDiagram}.
		}
		\label{fig:edgeForce}
\end{figure}
\FloatBarrier   % prevents floats from passing this point
\vspace{3cm}
\text{ }

\begin{figure}[t!]
    \centering
        \includegraphics[width=0.7\textwidth]{forces/edge1/energies-show-edgeForce.png} 
    \caption{This energy diagram shows that the edge force nearly restores the desired edge lengths after 5 time steps.}
	\label{fig:edgeEnergyDiagram}    
\end{figure}

\vspace{3cm}



	

\FloatBarrier 
\subsection{Interior angle force}
% mention scaling factor of /360 for interior angle force 
The combined application of the area and edge forces revealed instabilities in unfavorable configurations, where self intersections of the cell edges occurred. 
Simulations without this energy sometimes can also result in constrictions at certain vertices, where the interior angle approaches $360$째. 
To address this issue, we introduce the interior angle energy. \\
The first challenge is to consistently determine the interior angle at a given vertex throughout the simulation.
Although we could apply the law of cosines and use $\arccos$ to compute the angle, this method would suffer from poor stability as the angle approaches $180$째.
A better alternative is to use the $\atanxy$ function, as it remains reliably stable at all angles. \\

\begin{definition} \textbf{arctan2} \\
	For the vector $\vec{v} = (v^x, v^y)^T$, the function 
	\[
		\atanxy:\R^2/\{0\} \rightarrow (-\pi, \pi],
	\]  
	is defined by
	\begin{center}
		$ \atanxy(\vec{v}) = 
		\begin{cases}
			\arctan(\frac{v^{y}}{v^{x}}) & v^{x} > 0, \\
			\arctan(\frac{v^{y}}{v^{x}}) + \pi & v^{x} < 0, v^{y} > 0, \\
			\arctan(\frac{v^{y}}{v^{x}}) - \pi & v^{x} < 0, v^{y} < 0, \\
			\pi & v^{x} < 0, v^{y} = 0, \\
			\dfrac{\pi}{2} & v^{x} = 0, v^{y} > 0, \\ 		
			- \dfrac{\pi}{2} & v^{x} = 0, v^{y} < 0. \\ 
		\end{cases} $
	\end{center}
\end{definition}

The $\atanxy(\vec{v})$ function computes the angle of a vector $\vec{v}$ with respect to the positive $x$-axis. \\
With this, we can compute the angles 
\begin{center}
	$\theta_1 = \atanxy( \vec{v}_{j-1} - \vec{v_j} )$, \\
	$\theta_2 = \atanxy( \vec{v}_{j+1} - \vec{v_j} )$,
\end{center}
between the positive $x$-axis and the vectors from $\vec{v}_j$ to its neighboring vertices $\vec{v}_{j-1}$ and $\vec{v}_{j+1}$. 
We get the searched angle at $\vec{v}_j$ by subtracting $\theta_1 - \theta_2$.
To ensure that the angle lies within the interval $[0, 2\pi)$, we use the modulo operator $[ \cdot ]_{[0,2\pi)}$.
Thus, our interior angle operator is
\begin{center}
	$
	I^j_C = [\atanxy(\vec{v}_{j-1} - \vec{v_j}) - \atanxy(\vec{v}_{j+1} - \vec{v_j})]_{[0,2\pi)}.
	$
\end{center}

With that, we can define our interior angle energy. 
\begin{definition} \textbf{Interior angle energy} \\
	The energy $I: (\R^2)^{N_V} \rightarrow \R_{\geq 0}$ associated with preserving the cell interior angles is given by
	\begin{align}
		I_k(C) = \sum\limits_{j=1}^{N_V} \tfrac{1}{k}| I^j_{C} - I^{j}_d |^k,  \label{eq:intAngleEnergy}
	\end{align}
	where $I^{j}_d$ is the desired interior angle at vertex $j$ and $I^j_{C}$ is the current interior angle at vertex $j$ of the considered cell. 
\end{definition}


We continue by computing the resulting force. 
The $\atanxy$ function is partly defined and not truly differentiable. 
We still want to compute a gradient to use it for our interior angle force. 
It is 
\[
	\atanxy(\vec{v}) = \arctan\!\left(\frac{v^{y}}{v^{x}} \right) + \text{constant},
\]
almost everywhere, just not on areas with measure zero. 
We just compute the gradient of $\arctan(\frac{v^{y}}{v^{x}})$ instead. \\
Another problem is the modulo operator $[ \cdot ]_{[0,2\pi)}$, which is not differentiable at the interval limits.
However, we just neglect the modulo operator as it does not affect the dynamics of the gradient.

\begin{figure}
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\textwidth]{forces/angle1/t0.png} &
        \includegraphics[width=0.45\textwidth]{forces/angle1/t3.png} \\
        \includegraphics[width=0.45\textwidth]{forces/angle1/t5.png} &
        \includegraphics[width=0.45\textwidth]{forces/angle1/t19.png} \\
    \end{tabular}
		\caption{The top four plots depict the evolution of a DF cell subject only to the interior angle force with $k=2$ applied to the vertices and a force scaling of $1\times 10^{-1}$, at times $t \in \{0, 3\times 10^{-5}, 5\times 10^{-5}, 19\times 10^{-5}\}$.
			In this case, we have $\frac{\dequ \vec{v}}{\dequ t} = - 1\times 10^{-1}\, \nabla_{\vec{v}} I_2(C)$ for all vertices.
			At the vertex with initial position $\vec{v}_1 = (0.003, 0.0)^T$, the starting interior angle is $306.9$째, while all desired interior angles are $120$째.
			Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-intAngleForce.gif}{\textit{here}} to view the corresponding animation (GIF).
			As seen in Figure~\ref{fig:angleEnergyDiagram}, the interior angle force requires more time to reach the target configuration. 
			This slower convergence is due to the reduced force scaling, which was necessary to avoid stability issues encountered at higher force scaling values. }
	\label{fig:angleForce}
\end{figure}

\begin{figure}
    \centering
        \includegraphics[width=0.7\textwidth]{forces/angle1/energies-show-intAngleForce.png} 
    \caption{The interior angle force is able to minimise the interior angle energy over time.}
	\label{fig:angleEnergyDiagram}    
\end{figure}

\FloatBarrier


\begin{proposition} \textbf{Interior angle force} \label{prop:intAngleForce} \\
	% The interior angle force $F^{(I)}_j(C): (\R^2)^{N_V} \rightarrow \R^2$ that gets applied on vertex $\vec{v}_j$ of cell $C$ is given by 
	% \begin{align}
	% 	\begin{split}
	% 		F^{(I)}_j(C) &= - \nabla_{\vec{v}_j} I(C)  \\
	% 			&= (I^{j-1}_d - I^{j-1}_{C}) \left( 
	% 				- \frac{1}{\norm[\vec{v}_{j} - \vec{v}_{j-1}]^{y}} \begin{pmatrix}
	% 					v_{j}^{y} - v_{j-1}^{y} \\[0.5em]
	% 					v_{j-1}^{x} - v_{j}^{x}
	% 				\end{pmatrix} 
	% 			\right) \\[0.5em] 
	% 		&+ (I^{j}_d - I^{j}_{C}) \left( 
	% 			\frac{1}{\norm[\vec{v}_{j-1} - \vec{v}_j]^{y}} \begin{pmatrix}
	% 			v_{j-1}^{y} - v_{j}^{y} \\[0.5em]
	% 			v_{j}^{x} - v_{j-1}^{x}
	% 			\end{pmatrix} 
	% 			- \frac{1}{\norm[\vec{v}_{j+1} - \vec{v}_j]^2} \begin{pmatrix}
	% 			v_{j+1}^{y} - v_{j}^{y} \\[0.5em]
	% 			v_{j}^{x} - v_{j+1}^{x}
	% 			\end{pmatrix} 
	% 			\right) \\[0.5em] 
	% 		&+ (I^{j+1}_d - I^{j+1}_{C}) \left( 
	% 			\frac{1}{\norm[\vec{v}_{j} - \vec{v}_{j+1}]^2} \begin{pmatrix}
	% 			v_{j}^{y} - v_{j+1}^{y} \\[0.5em]
	% 			v_{j+1}^{x} - v_{j}^{x}
	% 			\end{pmatrix} 
	% 			\right) %\\[0.5em] 
	% 	\end{split}
	% \end{align}
	The interior angle force $F_{k}^{(I)}: (\R^2)^{N_V} \rightarrow (\R^2)^{N_V}$ that gets applied on cell $C$ is given by  
	\begin{align*}
		F_{k}^{(I)}(C) 
		= - (\nabla_{\vec{v}_1} I_k(C), \ldots, \nabla_{\vec{v}_{N_V}} I_k(C))^T,
	\end{align*}
	where the gradient $\nabla_{\vec{v}_j} I_k(C)$ with respect to $\vec{v}_j = (v_{j}^{x}, v_{j}^{y})^T$ is given by 
	\begin{align}
		\begin{split}
			\nabla_{\vec{v}_j} I_k(C) &= \sgn(I^{j-1}_{C} - I^{j-1}_d) |I^{j-1}_{C} - I^{j-1}_d|^{k-1} \left( 
					- \frac{1}{\norm[\vec{v}_{j} - \vec{v}_{j-1}]^{2}} \begin{pmatrix}
						v_{j-1}^{y} - v_{j}^{y} \\[0.5em]
						v_{j}^{x} - v_{j-1}^{x}
					\end{pmatrix} 
				\right) \\[0.5em] 
			&+ \sgn(I^{j}_{C} - I^{j}_d)|I^{j}_{C} - I^{j}_d|^{k-1} \Biggl( 
				\frac{1}{\norm[\vec{v}_{j-1} - \vec{v}_j]^{2}} \begin{pmatrix}
				v_{j-1}^{y} - v_{j}^{y} \\[0.5em]
				v_{j}^{x} - v_{j-1}^{x}
				\end{pmatrix} \\
			& \quad - \frac{1}{\norm[\vec{v}_{j+1} - \vec{v}_j]^2} \begin{pmatrix}
				v_{j+1}^{y} - v_{j}^{y} \\[0.5em]
				v_{j}^{x} - v_{j+1}^{x}
				\end{pmatrix} 
				\Biggr) \\[0.5em] 
			&+ \sgn(I^{j+1}_{C} - I^{j+1}_d) |I^{j+1}_{C} - I^{j+1}_d|^{k-1} \left( 
				\frac{1}{\norm[\vec{v}_{j} - \vec{v}_{j+1}]^2} \begin{pmatrix}
				v_{j+1}^{y} - v_{j}^{y} \\[0.5em]
				v_{j}^{x} - v_{j+1}^{x}
				\end{pmatrix} 
				\right), %\\[0.5em] 
		\end{split}
		\label{gradient:angle}
	\end{align}
	for all $1 \leq j \leq N_V$.\\

	Proof. \\
	We are looking for 
	\begin{center}
		$
		\nabla_{\vec{v}_j} I_k(C).
		$
	\end{center}
	
	Vertex $\vec{v}_j$ impacts the interior angles at $\vec{v}_{j-1}$, $\vec{v}_j$ and $\vec{v}_{j+1}$. 
	Thus, we get 
	\begin{align*}
		\nabla_{\vec{v}_j}  I_{k}(C) &=  \nabla_{\vec{v}_j} \sum\limits_{j=1}^{N_V} \tfrac{1}{k}| I^{j}_d - I^j_{C} |^k \\
		&= \nabla_{\vec{v}_j} \tfrac{1}{k}| I^{j-1}_d - I^{j-1}_{C} |^k 
		+ \nabla_{\vec{v}_j} \tfrac{1}{k}| I^{j}_d - I^{j}_{C} |^k
		+ \nabla_{\vec{v}_j} \tfrac{1}{k}| I^{j+1}_d - I^{j+1}_{C} |^k.
	\end{align*}
	First, we will focus on the computation
	\begin{align*}
		\nabla_{\vec{v}_j} \tfrac{1}{k}| I^{j}_d - I^{j}_{C} |^k 
		&= (I^{j}_d - I^j_{C}) \nabla_{\vec{v}_j} (- I^j_{C})\\
		&= (I^j_{C} - I^{j}_d) \nabla_{\vec{v}_j}  I^j_{C}   \\
		&= (I^j_{C} - I^{j}_d) \nabla_{\vec{v}_j} [\atanxy(\vec{v}_{j-1} - \vec{v_j}) - \atanxy(\vec{v}_{j+1} - \vec{v_j})]_{[0,2\pi)}.
	\end{align*}
	At this point, the previously mentioned simplifications come into play and we use $\arctan\! \left(\frac{v_{j-1}^{y} - v_{j}^{y}}{v_{j-1}^{x} - v_{j}^{x}} \right)$ instead of $\atanxy(\vec{v}_{j-1} - \vec{v_j})$ and neglect the modulo operator. \\
	In the next step, we need to compute the gradient 
	\begin{center}
		$
		\nabla_{\vec{v}_j} \arctan\! \left(\dfrac{v_{j-1}^{y} - v_{j}^{y}}{v_{j-1}^{x} - v_{j}^{x}} \right).
		$
	\end{center}
	
	Therefore, we define helper functions 
	$$ f(\vec{v}) = \arctan\!\left( \frac{v^{y}}{v^{x}} \right),$$ 
	and 
	$$g(\vec{v}_{j-1}, \vec{v}_{j}) = \begin{pmatrix}
		v_{j-1}^{x} - v_{j}^{x} \\[0.5em] 
		v_{j-1}^{y} - v_{j}^{y}
	\end{pmatrix}.$$
	With these helper functions, we can write 
	$$ \arctan\!\left(\frac{v_{j-1}^{y} - v_{j}^{y}}{v_{j-1}^{x} - v_{j}^{x}}\right) = (f \circ g) (\vec{v}_{j-1}, \vec{v}_{j}), $$
	and use the two-dimensional chain rule to compute stepwise the searched gradient. 
	We have 
	\begin{center}
		$\dfrac{\partial f(\vec{v})}{\partial v^{x}} = \dfrac{1}{1 + \left(\tfrac{v^{y}}{v^{x}}\right)^2} \left(- \dfrac{v^{y}}{(v^{x})^2}\right) = - \dfrac{v^{y}}{(v^{x})^2 + (v^{y})^2}$, \\[0.5em]
		$\dfrac{\partial f(\vec{v})}{\partial v^{y}} = \dfrac{1}{1 + \left(\tfrac{v^{y}}{v^{x}}\right)^2}  \dfrac{1}{v^{x}} =  \dfrac{v^{x}}{(v^{x})^2 + (v^{y})^2}$, 
	\end{center}
	and 
	\begin{center}
		$ \dfrac{\partial g(\vec{v}_{j-1}, \vec{v}_{j})}{\partial v_j^{x}} = (-1, 0)^T$, \quad 
		$ \dfrac{\partial g(\vec{v}_{j-1}, \vec{v}_{j})}{\partial v_j^{y}} = (0, -1)^T$. 
	\end{center}

	With that, we can compute
	\begin{align*}
		\frac{\partial (f \circ g (\vec{v}_{j-1}, \vec{v}_j))}{\partial v_j^{x}} &= (\nabla f \circ g (\vec{v}_{j-1}, \vec{v}_j))^T \cdot \nabla_{v_j^{x}} g (\vec{v}_{j-1}, \vec{v}_j) \\[0.5em]
		&= \begin{pmatrix}
			- \frac{v_{j-1}^{y} - v_{j}^{y}}{(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2} \\[1.0em]
			\frac{v_{j-1}^{x} - v_{j}^{x}}{(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2}
		\end{pmatrix}^T
		\cdot 
		\begin{pmatrix}
			-1 \\
			0
		\end{pmatrix} \\[0.5em]
		&= \frac{v_{j-1}^{y} - v_{j}^{y}}{(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2} \\[0.5em]
		&= \frac{v_{j-1}^{y} - v_{j}^{y}}{\norm[\vec{v}_{j-1} - \vec{v}_j]^2},
	\end{align*}
	and similarly
	\begin{align*}
		\frac{\partial (f \circ g (\vec{v}_{j-1}, \vec{v}_j))}{\partial v_j^{y}} &= (\nabla f \circ g (\vec{v}_{j-1}, \vec{v}_j))^T \cdot \nabla_{v_j^{y}} g (\vec{v}_{j-1}, \vec{v}_j) \\[0.5em]
		&= \begin{pmatrix}
			- \frac{v_{j-1}^{y} - v_{j}^{y}}{(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2} \\[1.0em]
			\frac{v_{j-1}^{x} - v_{j}^{x}}{(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2}
		\end{pmatrix}^T
		\cdot 
		\begin{pmatrix}
			0 \\
			-1
		\end{pmatrix} \\[0.5em]
		&= - \frac{v_{j-1}^{x} - v_{j}^{x}}{(v_{j-1}^{x} - v_{j}^{x})^2 + (v_{j-1}^{y} - v_{j}^{y})^2} \\[0.5em]
		&= \frac{v_{j}^{x} - v_{j-1}^{x}}{\norm[\vec{v}_{j-1} - \vec{v}_j]^2}. 
	\end{align*}

	Overall, we get 
	\begin{align*}
		\nabla_{\vec{v}_j} \arctan\! \left(\frac{v_{j-1}^{y} - v_{j}^{y}}{v_{j-1}^{x} - v_{j}^{x}} \right) = \frac{1}{\norm[\vec{v}_{j-1} - \vec{v}_j]^2} \begin{pmatrix}
			v_{j-1}^{y} - v_{j}^{y} \\[0.5em]
			v_{j}^{x} - v_{j-1}^{x}
		\end{pmatrix}.
	\end{align*}
	
	Thus, we can come back to
	\begin{align*}
		\nabla_{\vec{v}_j} \tfrac{1}{k}| I^{j}_d - I^{j}_{C} |^k 
		&= (I^j_{C} - I^{j}_d) \nabla_{\vec{v}_j} \left(\arctan\!\left(\frac{v_{j-1}^{y} - v_{j}^{y}}{v_{j-1}^{x} - v_{j}^{x}}\right) - \arctan\!\left(\frac{v_{j+1}^{y} - v_{j}^{y}}{v_{j+1}^{x} - v_{j}^{x}}\right)\right) \\
		&= (I^j_{C} - I^{j}_d) \Biggl( 
		  \frac{1}{\norm[\vec{v}_{j-1} - \vec{v}_j]^2} \begin{pmatrix}
			v_{j-1}^{y} - v_{j}^{y} \\[0.5em]
			v_{j}^{x} - v_{j-1}^{x}
		\end{pmatrix} \\
		& \quad - \frac{1}{\norm[\vec{v}_{j+1} - \vec{v}_j]^2} \begin{pmatrix}
			v_{j+1}^{y} - v_{j}^{y} \\[0.5em]
			v_{j}^{x} - v_{j+1}^{x}
		\end{pmatrix} \Biggr).
	\end{align*}

	For the neighboring vertices, we need
	\begin{gather*}
		\nabla_{\vec{v}_j} \arctan\!\left( \frac{v_j^y - v_{j-1}^y}{v_j^x - v_{j-1}^x} \right), \quad \nabla_{\vec{v}_j} \arctan\!\left( \frac{v_j^y - v_{j+1}^y}{v_j^x - v_{j+1}^x} \right).
	\end{gather*}
	Therefore, we can use the same helper function \[f(\vec{v}) = \arctan\!\left( \frac{v^{y}}{v^{x}} \right),\]
	but we need different functions for $g$, as the arrangement of the vertex coordinates differs a bit. 
	We introduce \[g_{-}(\vec{v}_{j-1}, \vec{v}_{j}) = \begin{pmatrix}
		v_{j}^{x} - v_{j-1}^{x} \\[0.5em] 
		v_{j}^{y} - v_{j-1}^{y}
	\end{pmatrix} = - g(\vec{v}_{j-1}, \vec{v}_{j}),\] 
	and
	\[g_{+}(\vec{v}_{j}, \vec{v}_{j+1}) = \begin{pmatrix}
		v_{j}^{x} - v_{j+1}^{x} \\[0.5em] 
		v_{j}^{y} - v_{j+1}^{y}
	\end{pmatrix}.
	\] 
	The gradients are 
	\[
		\nabla_{v_j^x} g_{-}(\vec{v}_{j-1}, \vec{v}_{j}) = (1,0)^T, \quad \nabla_{v_j^y} g_{-}(\vec{v}_{j-1}, \vec{v}_{j}) = (0,1)^T,
	\]
	\[
	\nabla_{v_j^x} g_{+}(\vec{v}_{j-1}, \vec{v}_{j}) = (1,0)^T, \quad \nabla_{v_j^y} g_{+}(\vec{v}_{j-1}, \vec{v}_{j}) = (0,1)^T.
	\]
	Thus, the Jacobian of both $g_{-}$ and $g_{+}$ is the identity matrix and we can just neglect it in the following chain rules. 
	For the previous vertex, we get 
	\begin{align*}
		\nabla_{\vec{v}_j} &\tfrac{1}{k}| I^{j-1}_{C} - I^{j-1}_d |^k = \\[0.5em]
		&= \sgn(I^{j-1}_{C} - I^{j-1}_d)|I^{j-1}_{C} - I^{j-1}_d|^{k-1} \\
		& \quad \nabla_{\vec{v}_j} \left(\arctan\!\left(\frac{v_{j-2}^{y} - v_{j-1}^{y}}{v_{j-2}^{x} - v_{j-1}^{x}}\right) - \arctan\!\left(\frac{v_{j}^{y} - v_{j-1}^{y}}{v_{j}^{x} - v_{j-1}^{x}}\right)\right) \\[0.5em]
		&= \sgn(I^{j-1}_{C} - I^{j-1}_d)|I^{j-1}_{C} - I^{j-1}_d|^{k-1}  \nabla_{\vec{v}_j} \left(- \arctan\!\left(\frac{v_{j}^{y} - v_{j-1}^{y}}{v_{j}^{x} - v_{j-1}^{x}}\right)\right) \\[0.5em]
		&= \sgn(I^{j-1}_{C} - I^{j-1}_d)|I^{j-1}_{C} - I^{j-1}_d|^{k-1} (- \nabla_{\vec{v}_j} \left( f \circ g_{-}(\vec{v}_{j-1}, \vec{v}_{j-1}) \right)) \\[0.5em]
		&= \sgn(I^{j-1}_{C} - I^{j-1}_d)|I^{j-1}_{C} - I^{j-1}_d|^{k-1} (- (\nabla f) \circ g_{-}(\vec{v}_{j-1}, \vec{v}_{j-1})) \\[0.5em]
		&= \sgn(I^{j-1}_{C} - I^{j-1}_d)|I^{j-1}_{C} - I^{j-1}_d|^{k-1} \left(- \frac{1}{\norm[\vec{v}_j - \vec{v}_{j-1}]^2} (v_{j-1}^y - v_{j}^y, v_{j}^x - v_{j-1}^x )^T\right).		
	\end{align*}
	Finally, for the successor vertex, we get 
	\begin{align*}
		\nabla_{\vec{v}_j} &\tfrac{1}{k}| I^{j+1}_{C} - I^{j+1}_d |^k  = \\[0.5em]
		&= \sgn(I^{j+1}_{C} - I^{j+1}_d)|I^{j+1}_{C} - I^{j+1}_d|^{k-1} \\
		& \quad \nabla_{\vec{v}_j} \left(\arctan\!\left(\frac{v_{j}^{y} - v_{j+1}^{y}}{v_{j}^{x} - v_{j+1}^{x}}\right) - \arctan\!\left(\frac{v_{j+2}^{y} - v_{j+1}^{y}}{v_{j+2}^{x} - v_{j+1}^{x}}\right)\right) \\[0.5em]
		&= \sgn(I^{j+1}_{C} - I^{j+1}_d)|I^{j+1}_{C} - I^{j+1}_d|^{k-1} \nabla_{\vec{v}_j} \left(\arctan\!\left(\frac{v_{j}^{y} - v_{j+1}^{y}}{v_{j}^{x} - v_{j+1}^{x}}\right)\right) \\[0.5em]
		&= \sgn(I^{j+1}_{C} - I^{j+1}_d)|I^{j+1}_{C} - I^{j+1}_d|^{k-1} \nabla_{\vec{v}_j} \left( f \circ g_{+}(\vec{v}_{j-1}, \vec{v}_{j-1}) \right) \\[0.5em]
		&= \sgn(I^{j+1}_{C} - I^{j+1}_d)|I^{j+1}_{C} - I^{j+1}_d|^{k-1} (\nabla f) \circ g_{+}(\vec{v}_{j-1}, \vec{v}_{j-1}) \\[0.5em]
		&= \sgn(I^{j+1}_{C} - I^{j+1}_d)|I^{j+1}_{C} - I^{j+1}_d|^{k-1} \left(\frac{1}{\norm[\vec{v}_{j} - \vec{v}_{j+1}]^2} (v_{j+1}^y - v_{j}^y, v_{j}^x - v_{j+1}^x)^T \right).	
	\end{align*}
	Equation~\eqref{gradient:angle} now follows by summing up the three parts. \\
	\qed
\end{proposition}

Figure \ref{fig:angleForce} illustrates the isolated effect of the interior angle force.


\FloatBarrier

\subsection{Overlap force}
% explain the algorithm
Unlike the previous energies, which act independently on each cell, the overlap force is the first to account for interactions between multiple cells, thereby introducing cell-to-cell interaction into the simulation. 

\subsubsection*{Deforming overlap force}
The first overlap force, that we want to introduce, is an adapted form of the overlap force introduced in~\cite{Vogel2023}. 
It degenerates a cell overlap by influencing that cell shapes of the affected cells. \\
The challenging aspect of computing the overlap force lies in detecting overlaps within the cell system. 
\begin{definition} \textbf{Overlap cell}\\
	An overlap cell between two DF cells $C_i$ and $C_m$ is a DF cell in the sence of Definition~\ref{def:DF}, composed of all vertices of $C_i$ that lie inside $C_m$, all vertices of $C_m$ that lie inside $C_i$ and the intersection points of the cell walls of $C_i$ and $C_m$.
\end{definition}
Each pair of cells can have more than one overlap cell in unfavourable configurations.
To be able to catch the correct dynamic in all cases, we need to introduce the set of all overlaps between a pair of DF cells.
\begin{definition} \textbf{Set of overlaps $\Omega_{C_i,C_m}$}\\
	Let $C_i, C_m \in \vec{C}$ be two DF cells. 
	Then, the set of overlaps $\Omega_{C_i,C_m}$ is defined as
	\[
		\Omega_{C_i,C_m} = \{\, D \mid D \text{ is an overlap cell formed between } C_i \text{ and } C_m \,\}.
	\]
\end{definition}
Once all overlaps have been identified, we apply a dynamic similar to that of the area force, but with a desired area of zero. 
This generates a force that acts to eliminate the overlap by reducing its area to zero. 
The resulting force is then applied to the vertices of the original cells that define the overlapping region. \\
The first step in detecting overlaps is identifying the intersection points between cell boundaries.
Intersections can be identified by representing the cell edges as line segments and computing the intersection points between segments belonging to different cells. \\
Having found all intersections, we can apply the following algorithm, that can be used to compute all overlaps between two cells. 

\begin{algorithm} \textbf{Computation of a discrete overlap} \label{alge:discreteOverlap}
	\begin{itemize} 
		\itemsep0em 
		\item[] \text{INPUT:}
		\item Discrete cells  $C$and $\zeta$
		\item List $I$ of unused intersections of $C$ and $\zeta$ 
	\end{itemize}
	\begin{algorithmic}
		\Function{constructOverlap}{$C$, $\zeta$, $I$}		
			\State usedIntersections = List$\{$Intersection$\}$(I[1]) 
			\State newOverlap = List$\{$Vertices$\}$(I[1]) 
			\State currentIntersection = I[1]
			
			\For{counter = 1 : length(I)} 
			
				\If{counter is even}
					\State newPath, newIntersection = \textsc{findPath}(currentIntersection, $C$, $I$) 
				\Else 
					\State newPath, newIntersection = \textsc{findPath}(currentIntersection, $\zeta$, $I$) 
				\EndIf
				
				\State append!(newOverlap, newPath)
				\If{newIntersection == I[1]} 
					\State \Return newOverlap, usedIntersections
				\Else 
					\State append!(newOverlap, newIntersection)
					\State append!(usedIntersections, newIntersection) 
					\State currentIntersection = newIntersection
				\EndIf
			\EndFor
		\EndFunction
	\end{algorithmic}
	\begin{itemize} 
		\itemsep0em 
		\item[] \text{OUTPUT:}
		\item A single intersection `newOverlap' which occurs between $C$ and $\zeta$ and which uses vertices from  $C$ and $\zeta$ as well as only intersections from $I$
		\item A list `usedIntersections' of all intersection that are used in `newOverlap'
	\end{itemize}	
\end{algorithm}
The algorithm begins by selecting the first intersection point $I[1]$ from the list $I$ as the initial vertex of the overlap cell `newOverlap'. 
This point is also added to the list `usedIntersections' \\
Next, the function `getOverlap' calls another function, `\textsc{findPath}', which determines the path along the discrete cell $\zeta$ from the current intersection point to the next intersection in $I$ encountered while traversing the edges of $\zeta$. 
This next intersection is also returned by the function. 
The identified path is a list of vertices in $\zeta$ that lie strictly between the two intersections. 
It may be empty if the next intersection occurs on the same edge as the current one. 
Both the path and the newly found intersection are appended to `newOverlap', and the intersection is also added to the list usedIntersections.\\
Since each intersection implies changing the cell from which the overlapping cell uses the edges, `\textsc{findPath}' is now applied to the other cell. 
Again, it will deliver the next intersection as well as a list of the in between laying vertices. 
The vertex list always gets appended to `newOverlap'. \\
If the newly found intersection is equal to the initial intersection $I[1]$, then the construction of the discrete overlap cell `newOverlap' is complete. 
At this point, both `newOverlap' and `usedIntersections' can be returned by the function `\textsc{construct-Overlap}'. \\
Otherwise, the newly found intersection is appended to both `newOverlap' and `usedIntersections', and the process continues by calling `\textsc{findPath}' on the other discrete cell.   
This step is repeated until the starting intersection is reached, completing the overlap cell construction. \\
Once an overlap between $C$ and $\zeta$ has been successfully extracted, all intersections used in its construction can be removed from the list $I$, since each intersection point belongs to exactly one overlap. 
As long as $I$ is not empty, the function `\textsc{constructOverlap}' can be called again with the updated list to extract the next overlap. 
When $I$ is empty, we can be certain that all intersections between $C$ and $\zeta$ have been processed, and thus all overlaps between the two cells have been identified. \\
Each time `\textsc{findPath}' is called, it is not immediately clear in which direction the function should traverse the vertices of the given cell. 
However, the correct direction can be determined using the following approach. \\
Starting from the current intersection passed into the function, move a small distance in one direction along the edge of the given cell where the intersection is located. Next, check whether this new point lies within the boundaries of the other cell as well. 
If the point is found in both cells, the chosen direction is correct. 
If not, then the opposite direction must be used. \\ 
A simple method to determine whether a point lies inside a polygon is to draw a ray from the point to the outside of the polygon. 
The number of intersections between the ray and the polygon's edges determines the point's position. 
If the number of intersections is odd, the point is inside the polygon.
If it is even, the point is outside the polygon. \\
% until here the rewriting!! 
% then continue with the energy and the force 

After introducing the method for detecting overlaps, we can now define the overlap force, which acts on the cell vertices involved in an overlap. 
This force is first computed based on the geometry of the overlap and then distributed to the corresponding vertices of the original cells. \\

\begin{definition} \textbf{Deforming overlap energy} \\
	Let $C_i$ and $C_m$ be two cells from the system $\vec{C}$ and $\Omega_{C_i,C_m}$ be the set of all overlaps that appear between $C_i$ and $C_m$, like explained above. 
	Then, the total deforming overlap energy $\hat{O}_k : (\R^{2N_V})^{N_C} \rightarrow \R$ of the cell system is given by the formula 
	\begin{align}
		\hat{O}_k(\vec{C}) = \sum\limits_{i=1}^{N_C} \; \sum\limits_{m=i+1}^{N_C} \; \sum\limits_{D \,\in\, \Omega_{C_i,C_m}} \tfrac{1}{k}|A_{D}|^k,	
		\label{eq:overlapEnergy}
	\end{align} 
	where $A_{D}$ is the area of the overlap $D$.  \\
	We define the inner bracket to be the overlap energy of the cell pair $C_i$ and $C_m$
	\begin{align*}
		&\hat{O}_k^{i,m}: (\R^{2 N_V})^2 \: \longrightarrow \: \R, \\[0.5em]
		(C_i, C_m) \: \longmapsto \: &\hat{O}_k^{i,m}(C_i, C_m) = \sum\limits_{D\, \in\, \Omega_{C_i,C_m}} \tfrac{1}{k}|A_{D}|^k.
	\end{align*} 
\end{definition}

To decrease the overlap areas during the simulation, we evaluate the gradient flow of the area energy with a desired area of zero which indicates the direction of motion for each vertex for reducing the overlap areas.

\newcommand{\vargs}{\ensuremath{\vec{v}_{\text{out}}^{\: i}, \vec{v}_{\text{in}}^{\: i}, \vec{v}_{\text{out}}^{\: m}, \vec{v}_{\text{in}}^{\: m}}}
\newcommand{\tu}{\ensuremath{(\vec{v}_{\text{out}}^{\: m} - \vec{v}_{\text{out}}^{\: i}) \times (\vec{v}_{\text{in}}^{\: m} - \vec{v}_{\text{out}}^{\: m})}}
\newcommand{\tl}{\ensuremath{(\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}) \times (\vec{v}_{\text{in}}^{\: m} - \vec{v}_{\text{out}}^{\: m})}}
\newcommand{\tz}{\ensuremath{\dfrac{\tu}{\tl}}}
\newcommand{\w}{\ensuremath{\vec{v}_{\text{out}}^{\: i} + \tz (\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i})}}

\begin{definition} \textbf{Intersection point and adjacent vertices} \\
	The vertices of an overlap cell $D$ can be divided into the vertices that are either in $C_i$ in $C_m$, we call that set 
	\[
		V(D) = \{\vec{v} \in D \:|\: \vec{v} \in C_i \cup C_m \}, 
		\] 
	and into the vertices that are neither in $C_i$ nor $C_m$, named 
	\[
		W(D) = D \setminus V(D).
	\]
	All overlap vertices in $W(D)$ are intersections between the cells $C_i$ and $C_m$. \\
	Each intersection $\vec{w}$ is dependent on two vertices of each cell that limit the edges that intersect, where the intersection point $\vec{w}$ arises. \\
	We call those four vertices \textbf{adjacent} to the intersection $\vec{w}$. 
	All intersection adjacent vertices will get an extra deforming overlap dynamic applied, since they influence the overlap area, and thus the overlap energy, via the intersection point they create. \\
	From each cell we get one vertex that is part of the overlap cell, called the inside vertex, and one vertex that is not part of the overlap, called the outside vertex. 
	For each intersection $\vec{w} \in W(D)$, we call its adjacent vertices 
	\[
		\text{adj}(\vec{w}) = \{\vec{v}_{\text{in}}^{\: i}, \vec{v}_{\text{out}}^{\: i}, \vec{v}_{\text{in}}^{\: m}, \vec{v}_{\text{out}}^{\: m} \}. 
	\]
	In order to refer to the inside or outside vertices, we define the sets 
	\[ 
		\text{in}(\vec{w}) = \{\vec{v}_{\text{in}}^{\: i}, \vec{v}_{\text{in}}^{\: m} \}, \quad \text{out}(\vec{w}) = \{\vec{v}_{\text{out}}^{\: i}, \vec{v}_{\text{out}}^{\: m} \}.
	\]
	Figure~\ref{fig:adjacent} illustrates what the in- and outside vertices of an intersection are. \\
	Given the four adjacent vertices, we can always compute the intersection with the function:
	\begin{align*}
		& w: (\R^2)^4 \: \longrightarrow \:\R^2, \\[0.5em]
		(\vargs) \: \longmapsto\: &\vec{v}_{\text{out}}^{\: i} + \dfrac{(\vec{v}_{\text{out}}^{\: m} - \vec{v}_{\text{out}}^{\: i}) \times (\vec{v}_{\text{in}}^{\: m} - \vec{v}_{\text{out}}^{\: m})}{(\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}) \times (\vec{v}_{\text{in}}^{\: m} - \vec{v}_{\text{out}}^{\: m})} (\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}),
	\end{align*}
	where $(a^x, a^y)^T \times (b^x, b^y)^T = a^x b^y - a^y b^x$ denotes the two-dimensional cross product. \\
\end{definition}
\FloatBarrier
\vspace{1.5cm}
\text{}
\FloatBarrier
\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.7\textwidth]{forces/adjacentVertices.pdf}
		\caption{
			Here, we can see a DF cell setup with two cells having an overlap. 
			The intersection points $\vec{w}_1$ and $\vec{w}_2$ are marked green. 
			We can also see all inside vertices coloured in black and the outside vertices coloured in white.
			In this example, we have $\text{adj}(\vec{w}_1) = \{\vec{v}_1^{\:1}, \vec{v}_2^{\:1}, \vec{v}_2^{\:2}, \vec{v}_3^{\:2}\}$, $\text{in}(\vec{w}_1) = \{\vec{v}_1^{\:1}, \vec{v}_3^{\:2}\}$ and $\text{out}(\vec{w}_1) = \{\vec{v}_2^{\:1}, \vec{v}_2^{\:2}\}$ for the first intersection and $\text{adj}(\vec{w}_2) = \{\vec{v}_1^{\:1}, \vec{v}_6^{\:1}, \vec{v}_4^{\:2}, \vec{v}_5^{\:2}\}$, $\text{in}(\vec{w}_2) = \{\vec{v}_1^{\:1}, \vec{v}_4^{\:2}\}$ and $\text{out}(\vec{w}_2) = \{\vec{v}_6^{\:1}, \vec{v}_5^{\: 2}\}$ for the second intersection.
			}
		\label{fig:adjacent}
	\end{center}
\end{figure}


\begin{proposition} \textbf{Partial derivatives of intersection points} \\
	We use $w(\vargs)$ to compute the influence of the adjacent vertices to the intersection point via their partial derivatives.
	In this proposition, we compute the needed partial derivatives. \\
	We define the following auxiliary terms:
	\begin{align*}
		f = \tu, \quad 
		&g = \tl,\\[0.5em]
		t = \frac{f}{g}, \quad 
		&w = \vec{v}_{\text{out}}^{\: i} + t(\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}).
	\end{align*}
	It is sufficient to just compute the partial derivatives with respect to $\vec{v}_{\text{in}}^{\: i}$ and $\vec{v}_{\text{out}}^{\: i}$.
	If we want the dynamic for the vertices of the other cell, we just switch the arrangement of the arguments (switch $\vec{v}_{\text{in}}^{\: i}$ with $\vec{v}_{\text{in}}^{\: j}$ and $\vec{v}_{\text{out}}^{\: i}$ with $\vec{v}_{\text{out}}^{\: j}$) and then use the same partial derivatives as for the first cell. \\
	The partial derivatives are: 
	\begin{align}
		\begin{split}
			D_{\vec{v}_{\text{out}}^{\: i}} w(\vargs): (\R^2)^4 \longrightarrow \R^{2 \times 2}, \\[0.5em]
			D_{\vec{v}_{\text{out}}^{\: i}} w(\vargs) = (1-t)I_2 + \dfrac{g - f}{g^2}(\vec{v}_{\text{in}}^{\: i} - &\vec{v}_{\text{out}}^{\: i}) \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}^T,
		\end{split}
		\label{equ:dwv_out}
	\end{align}

	\begin{align}
		\begin{split}
			D_{\vec{v}_{\text{in}}^{\: i}} w(\vargs): (\R^2)^4 \longrightarrow \R^{2 \times 2}, \\[0.5em]
			D_{\vec{v}_{\text{in}}^{\: i}} w(\vargs) = t I_2 \:+\: \dfrac{f}{g^2}(\vec{v}_{\text{in}}^{\: i} \;-\; &\vec{v}_{\text{out}}^{\: i}) \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}^T.
		\end{split}
		\label{equ:dwv_in}
	\end{align}

	Proof.\\

	First of all, we compute the gradients of $f$ and $g$
	\begin{align*}
		\nabla_{\vec{v}_{\text{out}}^{\: i}} f 
		&= \nabla_{\vec{v}_{\text{out}}^{\: i}}[(v_{\text{out}}^{m, x} - v_{\text{out}}^{i, x})(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) - (v_{\text{out}}^{m, y} - v_{\text{out}}^{i, y})(v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x})] \\[0.5em]
		&= \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}, 
	\end{align*}

	\begin{align*}
		\nabla_{\vec{v}_{\text{in}}^{\: i}} f 
		&= \nabla_{\vec{v}_{\text{in}}^{\: i}}[(v_{\text{out}}^{m, x} - v_{\text{out}}^{i, x})(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) - (v_{\text{out}}^{m, y} - v_{\text{out}}^{i, y})(v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x})] \\[0.5em]
		&= \begin{pmatrix}
			0 \\
			0
		\end{pmatrix}, 
	\end{align*}

	\begin{align*}
		\nabla_{\vec{v}_{\text{out}}^{\: i}} g
		&= \nabla_{\vec{v}_{\text{out}}^{\: i}}[(v_{\text{in}}^{i, x} - v_{\text{out}}^{i, x})(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) - (v_{\text{in}}^{i, y} - v_{\text{out}}^{i, y})(v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x})] \\[0.5em]
		&= \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}, 
	\end{align*}

	\begin{align*}
		\nabla_{\vec{v}_{\text{in}}^{\: i}} g
		&= \nabla_{\vec{v}_{\text{in}}^{\: i}}[(v_{\text{in}}^{i, x} - v_{\text{out}}^{i, x})(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) - (v_{\text{in}}^{i, y} - v_{\text{out}}^{i, y})(v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x})] \\[0.5em]
		&= \begin{pmatrix}
			v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y} \\[0.5em]
			-(v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x})
		\end{pmatrix}. \\[2em]
	\end{align*}
	Now, we can succeed with the gradients of $t$
	\begin{align*}
		\nabla_{\vec{v}_{\text{out}}^{\: i}} t
		&= \nabla_{\vec{v}_{\text{out}}^{\: i}} \dfrac{f}{g} \\
		&= \dfrac{(\nabla_{\vec{v}_{\text{out}}^{\: i}} f) g - (\nabla_{\vec{v}_{\text{out}}^{\: i}} g) f}{g^2} \\[0.5em]
		&= \dfrac{1}{g^2} \left(\begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix} g - \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix} f\right)\\[0.5em]
		&= \dfrac{g - f}{g^2} \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix},\\[2em]
	% \end{align*}
	% \begin{align*}	
		\nabla_{\vec{v}_{\text{in}}^{\: i}} t
		&= \nabla_{\vec{v}_{\text{in}}^{\: i}} \dfrac{f}{g} \\
		&= \dfrac{(\nabla_{\vec{v}_{\text{in}}^{\: i}} f) g - (\nabla_{\vec{v}_{\text{in}}^{\: i}} g) f}{g^2} \\[0.5em]
		&= \dfrac{1}{g^2} \left( - \begin{pmatrix}
			v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y} \\[0.5em]
			-(v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x})
		\end{pmatrix} f\right) \\[0.5em]
		&= \dfrac{f}{g^2} \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}. \\[0.5em]
	\end{align*}

	And finally, we can compute the partial derivatives of $w = (w_1, w_2)^T$
	\begin{align*}
		\dfrac{\partial w_1}{\partial v_{\text{out}}^{i, x}} = 1 + \dfrac{\partial t}{\partial v_{\text{out}}^{i, x}}(v_{\text{in}}^{i, x}- v_{\text{out}}^{i, x}) - t, &\quad 
		\dfrac{\partial w_1}{\partial v_{\text{out}}^{i, y}} = 0 + \dfrac{\partial t}{\partial v_{\text{out}}^{i, y}}(v_{\text{in}}^{i, x}- v_{\text{out}}^{i, x}) + 0, \\[0.5em]
		\dfrac{\partial w_2}{\partial v_{\text{out}}^{i, x}} = 0 + \dfrac{\partial t}{\partial v_{\text{out}}^{i, x}}(v_{\text{in}}^{i, y}- v_{\text{out}}^{i, y}) + 0, &\quad 
		\dfrac{\partial w_2}{\partial v_{\text{out}}^{i, y}} = 1 + \dfrac{\partial t}{\partial v_{\text{out}}^{i, y}}(v_{\text{in}}^{i, y}- v_{\text{out}}^{i, y}) - t, \\[1.5em]
	% \end{align*}
	% \begin{align*}
		 \Longrightarrow D_{\vec{v}_{\text{out}}^{\: i}} w = (1-t)I_2 + (\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}) &(\nabla_{\vec{v}_{\text{out}}^{\: i}} t)^T \\[0.5em]
		 = (1-t)I_2 + (\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}) &\left(\dfrac{g - f}{g^2} \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}\right)^T \\%[0.5em]
		 = (1-t)I_2 + \dfrac{g - f}{g^2}(\vec{v}_{\text{in}}^{\: i} - &\vec{v}_{\text{out}}^{\: i}) \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}^T, %\\[0.5em]
	\end{align*}

	\begin{align*}
		\dfrac{\partial w_1}{\partial v_{\text{in}}^{i, x}} = \dfrac{\partial t}{\partial v_{\text{in}}^{i, x}}(v_{\text{in}}^{i, x}- v_{\text{out}}^{i, x}) + t, &\quad 
		\dfrac{\partial w_1}{\partial v_{\text{in}}^{i, y}} = \dfrac{\partial t}{\partial v_{\text{in}}^{i, y}}(v_{\text{in}}^{i, x}- v_{\text{out}}^{i, x}) + 0, \\[0.5em]
		\dfrac{\partial w_2}{\partial v_{\text{in}}^{i, x}} = \dfrac{\partial t}{\partial v_{\text{in}}^{i, x}}(v_{\text{in}}^{i, y}- v_{\text{out}}^{i, y}) + 0, &\quad 
		\dfrac{\partial w_2}{\partial v_{\text{in}}^{i, y}} = \dfrac{\partial t}{\partial v_{\text{in}}^{i, y}}(v_{\text{in}}^{i, y}- v_{\text{out}}^{i, y}) + t, \\[1.5em]
	\end{align*}
	\begin{align*}
		\Longrightarrow D_{\vec{v}_{\text{in}}^{\: i}} w = t I_2 + (\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}) &(\nabla_{\vec{v}_{\text{in}}^{\: i}} t)^T \\[0.5em]
		= t I_2 + (\vec{v}_{\text{in}}^{\: i} - \vec{v}_{\text{out}}^{\: i}) &\left(\dfrac{f}{g^2} \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}\right)^T \\[0.5em]
		= \; t I_2 \:+\: \dfrac{f}{g^2}(\vec{v}_{\text{in}}^{\: i} \;-\; &\vec{v}_{\text{out}}^{\: i}) \begin{pmatrix}
			-(v_{\text{in}}^{m, y} - v_{\text{out}}^{m, y}) \\[0.5em]
			 v_{\text{in}}^{m, x} - v_{\text{out}}^{m, x}
		\end{pmatrix}^T. \\[0.5em]
	\end{align*}

	
\end{proposition}

\begin{proposition} \textbf{Deforming overlap force} \label{force:deformingOverlap}\\
	Each overlap cell $D \in \Omega_{C_i,C_m}$ is a list of vertices, that form the overlap, just like a DF cell. \\
	The deforming overlap gradient is then given by 
	\begin{align}
		\begin{split}
			\nabla_{\vec{v}_j^{\: i}} \hat{O}_k(\vec{C}) &= \sum\limits_{D \in \Omega_{C_i,C_m}}  |A_{D}|^{k-1} \Biggl(\mathbf{1}_{V(D)}(\vec{v}_j^{\: i}) \nabla_{\vec{v}_j^{\: i}}A_D  + \\[0.5em]
				    							   &+ \sum\limits_{\vec{w} \in W(D)} \left(\mathbf{1}_{\text{out}(w)}(\vec{v}_{j}^{\: i}) D_{\vec{v}_{\text{out}}^{\: i}} \vec{w} %+ \\
													+ \mathbf{1}_{\text{in}(w)}(\vec{v}_j^{\: i}) D_{\vec{v}_{\text{in}}^{\: i}} \vec{w} \right) \nabla_{\vec{w}}A_D\Biggr),
		\end{split}
		\label{grad:overlap}
	\end{align}
	for all $1 \leq j \leq N_V$ and $1 \leq i \leq N_C$, where $\text{out}(w)$, $\text{in}(w) \subset \text{adj}(w)$ denote the sets of outside and inside overlap-adjacent vertices, respectively. 
	Note, that the Formulas \ref{equ:dwv_out} and \ref{equ:dwv_in} define $\frac{\partial \vec{w}}{\partial \vec{v}_{j, out}^{\: i}}$ and $\frac{\partial \vec{w}}{\partial \vec{v}_{j, in}^{\: i}}$, respectively. \\
	The difference between $\nabla_{\vec{v}_j^{\: i}}A_D$ and $\nabla_{\vec{w}}A_D$ is that $\nabla_{\vec{v}_j^{\: i}}A_D$ uses the neighboring overlap vertices of $\vec{v}_j^{\: i}$ itself in the Area Gradient Formula \ref{gradient:area}, whereas $\nabla_{\vec{w}}A_D$ uses the neighbors of the corresponding intersection point in $D$, which is not the same overlap vertex as $\vec{v}_j^{\: i}$.
    $A_{D}$ is the area of the overlap $D$.
	The indicator function $\mathbf{1}_{A}(\vec{v})$ equals one, if $\vec{v} \in A$ and is zero otherwise. \\
	The deforming overlap force $F_{k}^{\hat{(O)}}: (\R^{2 N_V})^{N_C} \rightarrow (\R^{2 N_V})^{N_C}$ that gets applied on the whole cell system $\vec{C} = (C_1, \ldots, C_{N_C})$ is then given by  
	\begin{align*}
		F_{k}^{\hat{(O)}}(\vec{C}) 
		= - (\nabla_{\vec{v}_1^{\:1}} \hat{O}_k(\vec{C}), \ldots, \nabla_{\vec{v}_{N_V}^{\:1}} \hat{O}_k(\vec{C}), \; \cdots \;, \nabla_{\vec{v}_1^{\:N_C}} \hat{O}_k(\vec{C}), \ldots, \nabla_{\vec{v}_{N_V}^{\:N_C}} \hat{O}_k(\vec{C}))^T.
	\end{align*}
	For addressing the overlap force that acts on cell $1 \leq i \leq N_C$, we define 
	\begin{center}
		$F_{k, i}^{\hat{(O)}}: (\R^{2 N_V})^{N_C} \rightarrow (\R^{2 N_V})$, \\
		$F_{k, i}^{\hat{(O)}}(\vec{C}) = - (\nabla_{\vec{v}_1^{\:i}} \hat{O}_k(\vec{C}), \ldots, \nabla_{\vec{v}_{N_V}^{\:i}} \hat{O}_k(\vec{C}))^T$. 
	\end{center}
	\FloatBarrier
	\begin{figure}[h!]
		\centering
		\begin{tabular}{cc}
			\includegraphics[width=0.45\textwidth]{forces/defOverlap1/t0.png} &
			\includegraphics[width=0.45\textwidth]{forces/defOverlap1/t1.png} \\
			\includegraphics[width=0.45\textwidth]{forces/defOverlap1/t2.png} &
			\includegraphics[width=0.45\textwidth]{forces/defOverlap1/t3.png} \\
		\end{tabular}
		\caption{
			The top four plots show the evolution of a DF cell influenced solely by the deforming overlap force, with $k=1$ applied to the vertices and a force scaling of $6\times 10^{4}$, at times $t \in \{0, 1\times 10^{-5}, 2\times 10^{-5}, 3\times 10^{-5}\}$.
			In this case, we have $\frac{\dequ \vec{v}}{\dequ t} = - 6\times 10^{4}\, \nabla_{\vec{v}} \, \hat{O}_1(C_1, C_2)$ for all vertices.
			The overlap area $D$ is indicated below each plot.
			Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-DeformaingOverlapForce.gif}{\textit{here}} to view the corresponding animation (GIF).
			Initially, the overlap area is $3\times 10^{-5}$, which is relatively large compared to the cell area of $6.5\times 10^{-5}$. 
			However, it is completely resolved after just two time steps, as also illustrated in the energy diagram in Figure~\ref{fig:defOverlapEnergyDiagram}.
			}
			\label{fig:overlapForce}
	\end{figure}
	\FloatBarrier
	\begin{figure}[h!]
		\centering
        \includegraphics[width=0.7\textwidth]{forces//defOverlap1/energies-show-DeformaingOverlapForce.png} 
		\caption{The deforming overlap force resolves the overlap in two time steps.}
		\label{fig:defOverlapEnergyDiagram}    
	\end{figure}
	\FloatBarrier

	
	Proof of Proposition~\ref{force:deformingOverlap}. \\
	Note that $A_D$ depends on all vertices of the overlap cell $D$ and also on the first vertices of the overlap building cells that are adjacent to the intersection points, as they influence the position of the intersection points.
	Thus, we must differentiate between vertices $\vec{v}_j^{\: i}$ that are 
	\begin{itemize}
		\item not part of the overlap cell $D$ and not adjacent to any intersection point \\
		$\Leftrightarrow \vec{v}_j^{\: i} \notin D$ and $\vec{v}_j^{\: i} \notin \text{adj}(\vec{w}) \; \forall \vec{w} \in W(D)$, \\
		\item not part of the overlap cell $D$, but adjacent to a intersection point \\
		$\Leftrightarrow \vec{v}_j^{\: i} \notin D$ and $\exists \vec{w} \in W(D): \; \vec{v}_j^{\: i} \in \text{adj}(\vec{w})$, \\
		\item part of the overlap cell $D$ and not adjacent to any intersection point \\
		$\Leftrightarrow \vec{v}_j^{\: i} \in D$ and $\vec{v}_j^{\: i} \notin \text{adj}(\vec{w}) \; \forall \vec{w} \in W(D)$, \\
		\item part of the overlap cell $D$ and adjacent to any intersection point \\
		$\Leftrightarrow \vec{v}_j^{\: i} \in D$ and $\exists \vec{w} \in W(D): \; \vec{v}_j^{\: i} \in \text{adj}(\vec{w})$. \\
	\end{itemize}  
	These four cases are all considered in the following. \\ 
	Since the area $A_D$ is always positive, we can drop the absolute value. \\
	We aim to compute 
	\begin{align*}
		\nabla_{\vec{v}_j^{\: i}} \hat{O}_k(\vec{C}) 
		&= \nabla_{\vec{v}_j^{\: i}} \sum\limits_{i=1}^{N_C} \left( \sum\limits_{m=i+1}^{N_C} \left(\sum\limits_{D \in \Omega_{C_i,C_m}} \tfrac{1}{k}{A_{D}}^k\right) \right) \\
		&= \nabla_{\vec{v}_j^{\: i}} \sum\limits_{m \neq i} \hat{O}_k^{i,m}(C_i, C_m) \\
		&= \nabla_{\vec{v}_j^{\: i}} \sum\limits_{m \neq i} \sum\limits_{D \in \Omega_{C_i,C_m}} \tfrac{1}{k}{A_D}^k \\
		&= \sum\limits_{m \neq i} \sum\limits_{D \in \Omega_{C_i,C_m}} \nabla_{\vec{v}_j^{\: i}} \tfrac{1}{k}{A_D}^k. 
	\end{align*}
	Now, there are different cases. \\
	\textbf{Case 1:} $\vec{v}_j^{\: i} \notin D$ and $\vec{v}_j^{\: i} \notin \text{adj}(\vec{w}) \; \forall \vec{w} \in W(D)$\\
	In the first case, the considered vertex is neither a vertex from the overlap cell $D$, nor adjacent to any intersection point. \\
	Hence, this vertex has zero impact on the overlap and its gradient is zero, i.e.
	\begin{align*}
		\nabla_{\vec{v}_j^{\: i}} \tfrac{1}{k}{A_{D}}^k = 0.
	\end{align*}

	\textbf{Case 2:} $\vec{v}_j^{\: i} \notin D$ and $\exists \vec{w} \in W(D): \; \vec{v}_j^{\: i} \in \text{adj}(\vec{w})$\\
	For case 2, we consider a vertex that is not directly an overlap vertex, but it influences the overlap cell by influencing an intersection point $\vec{w}$. 
	This means that $\vec{v}_j^{\: i}$ is an outside adjacent vertex of the intersection $\vec{w}$. 
	We compute
	\begin{align*}
		\nabla_{\vec{v}_j^{\: i}} \tfrac{1}{k} {A_D}^k 
		&= {A_{D}}^{k-1} \nabla_{\vec{v}_j^{\: i}} A_D \\
		&= {A_{D}}^{k-1} \sum\limits_{\vec{w} \in W(D)} \mathbf{1}_{\text{out}(w)}(\vec{v}_{j}^{\: i}) D_{\vec{v}_{\text{out}}^{\: i}} \vec{w} \, \nabla_{\vec{w}}A_D, \\
	\end{align*}
	where, according to Equation~\eqref{equ:dwv_out}
	\begin{align*}
		D_{\vec{v}_{\text{out}}^{\: i}} \vec{w} = (1-t)I_2 + \dfrac{g - f}{g^2}(\vec{v}_{\text{in}}^{\: i} - &\vec{v}_j^{\: i}) \begin{pmatrix}
			-(v_{\text{in}}^{i, y} - v_{j}^{i, y}) \\[0.5em]
			 v_{\text{in}}^{i, x} - v_{j}^{i, x}
		\end{pmatrix}^T,
	\end{align*}
	because $\vec{v}_j^{\: i}$ is an outside vertex in this case and $\vec{v}_{\text{in}}^{\: i}$ is the vertex adjacent to $\vec{v}_j^{\: i}$ in cell $i$, such that these vertices build the edge causing the intersection. \\
	The gradient $\nabla_{\vec{w}}A_D$ can easily be computed via the Shoelace Formula~\ref{prop:Shoelace}, as in the area gradient from Formula~\ref{gradient:area}:
	\begin{align*}
		\nabla_{\vec{w}}A_D = \dfrac{1}{2} \begin{pmatrix} d_{j+1}^{y} - d_{j-1}^{y} \\[0.5em]  d_{j-1}^{x} - d_{j+1}^{x} \end{pmatrix},
	\end{align*}
	where $\vec{d}_{j-1}^{\: D} = (d_{j-1}^{x}, d_{j-1}^{y})^T$ and $\vec{d}_{j+1}^{\: D} = (d_{j+1}^{x}, d_{j+1}^{y})^T$ are the neighboring vertices of the intersection $\vec{w}$ in the overlap $D$.\\

	\textbf{Case 3:} $\vec{v}_j^{\: i} \in D$ and $\vec{v}_j^{\: i} \notin \text{adj}(\vec{w}) \; \forall \vec{w} \in W(D)$\\
	Now, $\vec{v}_j^{\: i}$ is a pure inside overlap vertex, in the sence that it does not have an intersection point as a neighbor in the overlap. 
	This dynamic is quite easy, since we just have to use the Shoelace Formula~\ref{prop:Shoelace} for once more: 
	\begin{align*}
		\nabla_{\vec{v}_j^{\: i}} \tfrac{1}{k} {A_D}^k 
		&= {A_{D}}^{k-1} \nabla_{\vec{v}_j^{\: i}} A_D \\
		&= {A_{D}}^{k-1} \mathbf{1}_{V(D)}(\vec{v}_j^{\: i}) \dfrac{1}{2} \begin{pmatrix} d_{j+1}^{y} - d_{j-1}^{y} \\[0.5em]  d_{j-1}^{x} - d_{j+1}^{x} \end{pmatrix},
	\end{align*}
	where $\vec{d}_{j-1}^{\: D} = (d_{j-1}^{x}, d_{j-1}^{y})^T$ and $\vec{d}_{j+1}^{\: D} = (d_{j+1}^{x}, d_{j+1}^{y})^T$ are the neighboring vertices of $\vec{v}_j^{\: i}$ in the overlap $D$.\\


	\textbf{Case 4:} $\vec{v}_j^{\: i} \in D$ and $\exists \vec{w} \in W(D): \; \vec{v}_j^{\: i} \in \text{adj}(\vec{w})$\\
	In the last case, the considered vertex is an overlap vertex and also adjacent to at least one intersection point. 
	Thus, we have to add both dynamics from the last two cases and then use the partial derivative for inside vertices. 
	\begin{align*}
		\nabla_{\vec{v}_j^{\: i}} \tfrac{1}{k} {A_D}^k 
		&= {A_{D}}^{k-1} \nabla_{\vec{v}_j^{\: i}} A_D \\
		&= {A_{D}}^{k-1} \Biggl(\mathbf{1}_{V(D)}(\vec{v}_j^{\: i}) \nabla_{\vec{v}_j^{\: i}}A_D %+ \\[0.5em]
							+ \sum\limits_{\vec{w} \in W(D)} \mathbf{1}_{\text{adj}(w)}(\vec{v}_j^{\: i}) D_{\vec{v}_j^{\: i}} \vec{w} \: \nabla_{\vec{w}}A_D \Biggr)\\[0.5em]
		&= {A_{D}}^{k-1} \Biggl(\mathbf{1}_{V(D)}(\vec{v}_j^{\: i}) \nabla_{\vec{v}_j^{\: i}}A_D  \\[0.5em]
							 &\quad + \sum\limits_{\vec{w} \in W(D)} \left(\mathbf{1}_{\text{out}(w)}(\vec{v}_{j}^{\: i}) D_{\vec{v}_{\text{out}}^{\: i}} \vec{w} \:\nabla_{\vec{w}}A_D %+ \\
		+ \mathbf{1}_{\text{in}(w)}(\vec{v}_j^{\: i}) D_{\vec{v}_{\text{in}}^{\: i}} \vec{w} \: \nabla_{\vec{w}}A_D\right) \Biggr)\\[0.5em]
		&= {A_{D}}^{k-1} \Biggl(\mathbf{1}_{V(D)}(\vec{v}_j^{\: i}) \nabla_{\vec{v}_j^{\: i}}A_D   \\[0.5em]
							 &\quad + \sum\limits_{\vec{w} \in W(D)} \left(\mathbf{1}_{\text{out}(w)}(\vec{v}_{j}^{\: i}) D_{\vec{v}_{\text{out}}^{\: i}} \vec{w} %+ \\
		+ \mathbf{1}_{\text{in}(w)}(\vec{v}_j^{\: i}) D_{\vec{v}_{\text{in}}^{\: i}} \vec{w} \right) \nabla_{\vec{w}}A_D\Biggr),
	\end{align*}
	where $\text{out}(w)$, $\text{in}(w) \subset \text{adj}(w)$ denote the sets of outside and inside overlap-adjacent vertices, respectively.\\
	The difference between $\nabla_{\vec{v}_j^{\: i}}A_D$ and $\nabla_{\vec{w}}A_D$ is, that $\nabla_{\vec{v}_j^{\: i}}A_D$ uses the neighboring overlap vertices of $\vec{v}_j^{\: i}$ itself in the Area Gradient Formula \ref{gradient:area}, whereas $\nabla_{\vec{w}}A_D$ uses the neighbors of the according intersection point in $D$ which is not the same overlap vertex as $\vec{v}_j^{\: i}$. 
	
	\textbf{Overall:}\\
	Actually, Case 4 already provides the final formulation, since in the other cases the additional terms vanish due to the indicator functions. \\		
	\qed
\end{proposition}

Figure~\ref{fig:overlapForce} illustrates the interaction between two overlapping cells, highlighting the effect of the overlap force on their vertices.





\FloatBarrier

\subsubsection*{Bounce overlap force} 
While the previously introduced overlap force effectively reduces cell overlap by deforming the cells' shapes, it does not directly separate them spatially - leaving cells temporarily stuck together, relying on random Brownian motion to diffuse apart. 
With just that force, it is hard to compare the DF cell model to the hard sphere cell model, where overlaps are solved by reflecting them away from each other, resulting in a real distance that both cells have after a really small amount of time. \\  
To address this limitation and ensure a smoother conceptual and mechanical transition from the hard disc cell model, where non-deformable cells simply bounce off one another, we introduce a second overlap degeneration force. 
This additional force, which we refer to as the bounce overlap force, acts not by changing cell shape but by actively transporting overlapping cells away from each other. 
This mechanism captures the spatial repulsion characteristic of rigid body interactions while complementing the shape based degeneration of overlaps in deformable cells. 
In the end, we will use a combination of both overlap forces to get a nice transition from the HCSM to the DF cell model. \\ 
In~\cite{Bruna2012} overlapping cells with a radius of $r$ that have a centre-to-centre distance of $2r - a$ will be reflective apart in one time step (that is $10^{-5}$), resulting in a distance of $2r + a$ between the two cell centres afterwards. \\
The following force does the exact same for our DF cells. 
But we need the following assumptions:
\begin{enumerate}
	\item Our DF cells model circular discs. 
	\item The cells have a radius of $r \in \R_{>0}$.
	\item We can compute the cell centre $\vec{x} = \frac{1}{N_V}\sum\limits_{j = 1}^{N_V} \vec{v}_j$ which will be used to determine the distance between two cells. 
\end{enumerate}


With that given, we can define the according energy. 

\begin{definition} \textbf{Bounce overlap energy} \\
    The energy underlying for the bounce overlap dynamics is defined as
    \begin{align}
		\begin{split}
			&\bar{O}: (\R^{2N_V})^{N_C} \: \longrightarrow \: \R_+, \\
			\vec{C} \: \longmapsto \: &\bar{O}(\vec{C}) = \frac{1}{N_C} \sum\limits_{i=1}^{N_C} \sum\limits_{j > i}^{N_C}  \left( \psi \circ \chi \right) (C_i - C_j),
		\end{split}
		\label{energy:bounce}
    \end{align}
    where we use two functions $\chi$ and $\psi$, defined as follows. \\
    The first function 
    \begin{align*}
        &\chi: \R^{2 N_V} \: \longrightarrow \: \R_+, \\
        (C_i - C_j) \: \longmapsto \: &\chi(C_i - C_j) 
        = \norm[ \vec{x}_i - \vec{x}_j ],
    \end{align*} 
    maps the difference of two cells $C_i - C_j$ to the distance of their cell centres where a cell centre is computed as $\vec{x}_i = \frac{1}{N_V} \sum\limits_{k=1}^{N_V} \vec{v}^{\: i}_k$. 
    This formulation is feasible, as we can write 
    \[    
    C_i - C_j = \begin{pmatrix}    
        \vec{v}_1^{\:i} - \vec{v}_1^{\:j} \\ 
        \vdots \\ 
        \vec{v}_{N_V}^{\:i} -  \vec{v}_{N_V}^{\:j}
    \end{pmatrix},
    \]
    and then use this vector to compute the cell centre distance as 
    \[
        \norm[ \frac{1}{N_V} \left( \sum\limits_{k=1}^{N_V} (\vec{v}^{\: i}_k - \vec{v}^{\: j}_k) \right)] 
        = \norm[ \frac{1}{N_V} \sum\limits_{k=1}^{N_V} \vec{v}^{\: i}_k   - \frac{1}{N_V} \sum\limits_{k=1}^{N_V} \vec{v}^{\: j}_k]
        = \norm[ \vec{x}_i - \vec{x}_j ].
    \]
    \\
    The second function 
    \begin{align*}
        &\psi: \R_+ \: \longrightarrow \: \R_+, \\
        d \: \longmapsto \: &\psi(d) = \tfrac{N_V}{2} \mathbf{1}_{\{d < 2r\}} (2r - d)^2,
    \end{align*}
    penalises cell centre distances smaller than the threshold $2r$, where $r>0$ is the cell radius given in the simulation setup.
\end{definition}

At first glance, the bounce overlap energy appears to lack smoothness due to the presence of the indicator function in $\psi$. 
However, noting that the quadratic expression $(2r - d)^2$ vanishes at the transition point $d = 2r$ and that its first derivative is also zero there, we observe that the resulting energy is in fact continuously differentiable.  
With this regularity established, we proceed to compute the gradient required for the gradient flow dynamic.
We use a normalisation factor of $\frac{1}{N_C}$ in the energy definition to ensure that the interaction term remains of order $\mathcal{O}(1)$ as the number of cells $N_C \rightarrow \infty$, preventing unbounded growth in interaction strength in large cell populations. 

\begin{proposition} \textbf{Bounce overlap force} \label{prop:bounceForce}\\
    The bounce overlap force $F^{(\bar{O})}_i: (\R^{2N_V})^{N_C}\setminus\{0\} \rightarrow \R^{2N_V}$ that gets applied on cell $i$, is given by
    \begin{align*}
        F^{(\bar{O})}_i(\vec{C}) = -(\nabla_{\vec{v}^{\: i}_1} \bar{O}(\vec{C}), \ldots, \nabla_{\vec{v}^{\: i}_{N_V}} \bar{O}(\vec{C})),
    \end{align*}
	where the vertex wise gradient is given by 
	\begin{align}
		\nabla_{\vec{v}^{\: i}_k} \bar{O}(\vec{C}) = \frac{1}{N_C} \sum\limits_{j \neq i} \mathbf{1}_{\{\norm[\vec{x}_i - \vec{x}_j] < 2r\}} (\norm[\vec{x}_i - \vec{x}_j] - 2r)   \frac{\vec{x}_i - \vec{x}_j}{ \norm[\vec{x}_i - \vec{x}_j]},
	\end{align}
	for any $1\leq k \leq N_V$.\\

    Proof.\\
	We choose an arbitrary cell $1 \leq i \leq N_C$ and vertex $1 \leq k \leq N_V$. 
    Then, we consider the gradient with respect to the vertex $\vec{v}^{\: i}_k$ of the bounce overlap energy as
    \begin{align*}
        \nabla_{\vec{v}^{\: i}_k} \bar{O}(\vec{C}) 
        &= \nabla_{\vec{v}^{\: i}_k} \left[ \frac{1}{N_C} \sum\limits_{m=1}^{N_C} \sum\limits_{j > m}^{N_C}  \left( \psi \circ \chi \right) (C_m - C_j) \right] \\
        &= \frac{1}{N_C} \sum\limits_{j \neq i}  \nabla_{\vec{v}^{\: i}_k} \left[  \left( \psi \circ \chi \right) (C_i - C_j) \right] \\
        &= \frac{1}{N_C} \sum\limits_{j \neq i}  \psi'(\chi(C_i - C_j)) \nabla_{\vec{v}^{\: i}_k} \chi (C_i - C_j). \\
    \end{align*}
	For the derivative of $\psi$, we first consider $d \in [0,2r]$. 
    On this interval, we have
    \begin{align*}
        \psi'(d) 
        &= \frac{\dequ}{\dequ d} \left[\frac{N_V}{2} \mathbf{1}_{\{d < 2r\}}  (2r - d)^2\right] \\
        &= \frac{N_V}{2} \frac{\dequ}{\dequ d} \left[(2r - d)^2\right] \\
        &= \frac{N_V}{2} 2(2r - d) \frac{\dequ}{\dequ d} \left[(2r - d)\right] \\
        &= N_V (d - 2r).\\
    \end{align*}
	For $d=2r$, this we have a derivative of $\psi'(2r) = 0$. 
	As for $d>2r$, $psi$ is constant zero, we also have $\psi'(d) = 0$ for all $d > 2r$. 
	Overall, we get the continuous derivative 
	\begin{align*}
	    \psi'(d) = N_V \mathbf{1}_{\{d < 2r\}} (d - 2r).
	\end{align*} 
    % TODO: explain why \frac{\dequ}{\dequ d} \left[\mathbf{1}_{\{d < 2r\}}\right] (d - 2r)^2 = 0
    Thus, 
    \begin{align*}
    \psi'(\chi(C_i - C_j)) = \psi'(\norm[\vec{x}_i - \vec{x}_j]) = N_V \mathbf{1}_{\{\norm[\vec{x}_i - \vec{x}_j] < 2r\}} (\norm[\vec{x}_i - \vec{x}_j] - 2r).
    \end{align*}
    We continue with the gradient with respect to a vertex $\vec{v}^{\:i}_k$, $1 \leq k \leq N_V$, of cell $i$ as
    \begin{align*}
        \nabla_{\vec{v}^{\:i}_k} \chi (C_i - C_j) 
        &= \nabla_{\vec{v}^{\:i}_k} \norm[ \vec{x}_i - \vec{x}_j ] \\ 
        &= \nabla_{\vec{v}^{\:i}_k} \left[ \left( (x^x_i - x^x_j)^2 + (x^y_i - x^y_j)^2 \right)^{\tfrac{1}{2}} \right]  \\ 
        &= \tfrac{1}{2} \left( (x^x_i - x^x_j)^2 + (x^y_i - x^y_j)^2 \right)^{-\tfrac{1}{2}} \nabla_{\vec{v}^{\:i}_k} \left[ (x^x_i - x^x_j)^2 + (x^y_i - x^y_j)^2 \right] \\ 
        &= \frac{1}{2 \norm[\vec{x}_i - \vec{x}_j]} \begin{pmatrix}
            \tfrac{\partial}{\partial v^{i, x}_k} \left[ (x^x_i - x^x_j)^2  \right] \\[0.5em]
            \tfrac{\partial}{\partial v^{i, y}_k} \left[ (x^y_i - x^y_j)^2 \right] 
        \end{pmatrix} \\ 
        &= \frac{1}{2 \norm[\vec{x}_i - \vec{x}_j]} \begin{pmatrix}
            2 (x^x_i - x^x_j)\tfrac{\partial}{ \partial v^{i, x}_k} \left[ x^x_i - x^x_j \right] \\[0.5em]
            2 (x^y_i - x^y_j)\tfrac{\partial}{ \partial v^{i, y}_k} \left[ x^y_i - x^y_j \right] 
        \end{pmatrix} \\ 
        &= \frac{1}{ \norm[\vec{x}_i - \vec{x}_j]} \begin{pmatrix}
             (x^x_i - x^x_j) \tfrac{\partial}{  \partial v^{i, x}_k} \left[ \tfrac{1}{N_V} \sum\limits_{k=1}^{N_V} v^{i, x}_k \right] \\[0.5em]
             (x^y_i - x^y_j) \tfrac{\partial}{  \partial v^{i, y}_k} \left[ \tfrac{1}{N_V} \sum\limits_{k=1}^{N_V} v^{i, y}_k \right] 
        \end{pmatrix} \\ 
        &= \frac{1}{ \norm[\vec{x}_i - \vec{x}_j]} \begin{pmatrix}
             \tfrac{1}{N_V} (x^x_i - x^x_j)  \\[0.5em]
             \tfrac{1}{N_V} (x^y_i - x^y_j) 
        \end{pmatrix} \\ 
        &= \frac{1}{ N_V\norm[\vec{x}_i - \vec{x}_j]}  (\vec{x}_i - \vec{x}_j) .       
    \end{align*}
    We get the same gradient, no matter which $1 \leq k \leq N_V$ we choose.
	In the derivative, we get a quotient $$\frac{1}{ \norm[\vec{x}_i - \vec{x}_j]},$$ that is undefined for $\vec{x}_i - \vec{x}_j = 0 \in \R^2$.
	For a general function argument $B = (\vec{b}_1, \ldots, \vec{b}_{N_V}) \in \R^{2N_V}$, that we can interpret as a vector of $2$-dimensional vertices, the problematic division occurs whenever 
	\[
		\sum\limits_{k=1}^{N_V} \vec{b}_k = 0 \in \R^2,
	\]
	thus whenever the centre of mass of that vector of $2$-dimensional vertices is at the origin. 
	If we use the difference of two cells $C_i - C_j$ as function argument, this division by zero occurs whenever both cells have the same cell centre, i.e. $\vec{x}_i = \vec{x}_j$. 
	% As this dynamic works against this exact situation, we can safely assume that this case will not occur in practice. 
	In a numerical simulation, if you start with no exact centre coincidences and use a time step small enough that the repulsive dynamics prevent an exact same centre of mass, then $\norm[\vec{x}_i = \vec{x}_j]$ will not equal $0$ and the formula is safe to apply. \\
    Now, we can come back to the original computation 
    \begin{align*}
        \nabla_{\vec{v}^{\:i}_k} \bar{O}(\vec{C}) 
        &= \frac{1}{N_C} \sum\limits_{j \neq i}  \psi'(\chi(C_i - C_j)) \nabla_{\vec{v}^{\:i}_k} \chi (C_i - C_j) \\
        &= \frac{1}{N_C} \sum\limits_{j \neq i}  N_V \mathbf{1}_{\{\norm[\vec{x}_i - \vec{x}_j] < 2r\}} (\norm[\vec{x}_i - \vec{x}_j] - 2r) \frac{1}{ N_V\norm[\vec{x}_i - \vec{x}_j]} (\vec{x}_i - \vec{x}_j) \\
        &= \frac{1}{N_C} \sum\limits_{j \neq i} \mathbf{1}_{\{\norm[\vec{x}_i - \vec{x}_j] < 2r\}} (\norm[\vec{x}_i - \vec{x}_j] - 2r)   \frac{\vec{x}_i - \vec{x}_j}{ \norm[\vec{x}_i - \vec{x}_j]}. 
    \end{align*}
    \qed 
\end{proposition}

In order to achieve a similarly fast degeneration of the overlap as in~\cite{Bruna2012}, we need to scale the force with the scaling factor 
\(
\alpha^{(\bar{O})} = N_C \times 10^5
\)
as the time needed to resolve such an overlap in~\cite{Bruna2012} was always one time step which is $10^{-5}$ and we need to compensate the fraction $\frac{1}{N_C}$ that is needed for the mean field density computation in Chapter~\ref{density}. 
The according dynamic is shown in Figure~\ref{fig:bounceOverlapForce}.

To account for varying cell stiffness, we introduce a new parameter $h \in [0, 1]$ that controls how `hard' the cells are. 
The total overlap force is then defined as a weighted combination of two overlap force types
\[
	h \cdot F^{(\bar{O})} + (1 - h) \cdot F^{\hat{(O)}},
\]
where $F^{(\bar{O})}$ denotes the bounce off overlap force and $F^{\hat{(O)}}$ the shape deforming overlap force.\\
When $h = 1$, the cells are maximally stiff. 
In this case, shape deformation is entirely suppressed: all overlaps are resolved solely through the bounce off mechanism, and the shape preserving forces become redundant since the cells always retain their desired configurations. \\
As $h$ decreases, the cells become progressively softer. 
The influence of the bounce off force diminishes, while the shape deforming overlap force gains dominance, allowing cells to deform more in response to contact with neighbors. \\
With the introduction of the hardness parameter $h$, we have established a mechanism that enables a smooth transition from the HSCM dynamics introduced in~\cite{Bruna2012} to our new DF cell model. \\
For $h = 1$, the dynamics are identical to the original HSCM model, as we will show in the following chapter. 
By gradually decreasing $h$, we can continuously adapt the system behaviour toward the pure deformable (DF) cell model. 
In this way, we can systematically investigate how the dynamics evolve between the two regimes. 
In the limiting case $h = 0$, we recover the DF dynamics without the bounce overlap force term.


\begin{figure}
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\textwidth]{forces/bounceOverlap1/t0.png} &
        \includegraphics[width=0.45\textwidth]{forces/bounceOverlap1/t1.png} \\
        \includegraphics[width=0.45\textwidth]{forces/bounceOverlap1/t2.png} &
        \includegraphics[width=0.45\textwidth]{forces/bounceOverlap1/t3.png} \\
    \end{tabular}
			\caption{The top four plots present the evolution of a DF cell governed solely by the bounce overlap force, applied to the vertices with a force scaling of $2.0 \times 10^{5}$, as we used $N_C = 2$ cells for this example. 
			We consider the time instances $t \in \{0, 1\times 10^{-5}, 2\times 10^{-5}, 3\times 10^{-5}\}$.
			In this case, we have $\frac{\partial C_i}{\partial t} = 1\times 10^{5} \: F_i^{(\bar{O})}(C_1, C_2)$ for both cells.
			Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-bounceOverlapForce.gif}{\textit{here}} to view the corresponding animation (GIF).
			The overlap vanishes within the very first time step, leaving a visible gap between the two cells. 
			The corresponding energy development is illustrated in Figure~\ref{fig:bounceOverlapEnergyDiagram}.
		}
	\label{fig:bounceOverlapForce}   
\end{figure}

\begin{figure}[t!]
    \centering
        \includegraphics[width=0.7\textwidth]{forces/bounceOverlap1/energies-show-bounceOverlapForce.png} 
    \caption{The overlap energy reaches zero after one iteration.}
	\label{fig:bounceOverlapEnergyDiagram}    
\end{figure}

\FloatBarrier

\subsection{The DF SDE}
Having defined all individual force contributions acting on the cell vertices, we now combine them to formulate the full dynamics of the system in terms of a stochastic differential equation. \\
One challenging aspect that remains is the appropriate scaling of all forces.
It has become evident that the system is highly sensitive to these scaling parameters. 
If the shape recovering forces are too small, the recovery process is excessively slow. 
Conversely, if they are too large, the numerical integration scheme tends to become unstable. \\ 
To ensure numerical stability while preserving the intended dynamics, we systematically tested the appropriate scaling for each force type, focusing in particular on the shape preserving forces and the deforming overlap force.

Our method was to isolate each of these forces in simulation and determine the threshold at which the system becomes unstable. 
Specifically, we ran simulations with only one force active at a time and gradually increased its scaling factor until numerical instabilities emerged. 
We then selected the maximum stable scaling as the operative value for that force. \\
These tests were conducted using a fixed time step of $10^{-5}$, with cell configurations composed of six vertices. 
To rigorously challenge the model, we initialised the cells in deliberately distorted and uncomfortable shapes, which are most prone to triggering instabilities. 
The configurations used in these tests are the same as those shown in the figures throughout this chapter, where the isolated effects of each force were illustrated following their respective introductions. 
This allowed us to verify that the chosen scalings are robust even under unfavorable conditions. 
For the bounce overlap force, a scaling factor of $10^5$ is necessary to reproduce the original bounce off dynamics used in~\cite{Bruna2012}. \\
Summarizing all these efforts, we arrived at the following force scalings used in the simulations

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Force type} & \textbf{Scaling parameter} \\
		\hline
		\text{Area force} & $\alpha_A = 4.0 \times 10^8$ \\
		\text{Edge force} & $\alpha_E = 3.0 \times 10^4$ \\
		\text{Interior angle force} & $\alpha_I = 1.0 \times 10^{-1}$ \\
		\text{Deforming overlap force} & $\alpha_{\hat{O}} = 6.0 \times 10^4$ \\
		\text{Bounce overlap force} & $\alpha_{\bar{O}} = 4.0 \times 10^7$ \\
		\hline
	\end{tabular}
	\caption{Scaling parameters for different force types}
	\label{table:forcescalings}
\end{table}

These scaling parameters serve as the foundation for the complete DF SDE model, which we now introduce.
\begin{definition} \textbf{The DF SDE} \label{def:df-sde} \\
	We define the vectors
	\[
		e_{N_V}^{x} = (1,0,1,0,\ldots,1,0)^T, \quad e_{N_V}^{y} = (0,1,0,1,\ldots,0,1)^T \in \R^{2N_V},
	\]
	which allow us to distribute a two-dimensional Brownian motion 
	\[
		\dequ \vec{B}_i(t) = (\dequ B_i^{x}(t), \dequ B_i^{y}(t))^T,
	\] 
	to the $x$ and $y$ coordinates of the vertices of a cell, respectively.
	The cell hardness parameter $h \in [0,1]$ is assumed to be given.
	The deterministic part $\F^{i}(\vec{C})$ of the \textbf{DF SDE} is given by 
	\begin{align}
		\begin{split}
			& \F^i: (\R^{2N_V})^{N_C} \longrightarrow \R^{2N_V} , \\[0.5em]
			\F^{i}(\vec{C}) = \; & \alpha_{A} F_2^{(A)}(C_i) + \alpha_{E} F_2^{(E)}(C_i) + \alpha_{I} F_2^{(I)}(C_i) + \\
			& (1-h)\alpha_{\hat{O}} F_{1,i}^{(\hat{O})}(\vec{C}) + h \alpha_{\bar{O}} F_i^{(\bar{O})}(\vec{C}),
		\end{split}
		\label{DF-deterministic-force}
	\end{align}
	for each cell $1 \leq i \leq N_C$. \\ 
	Each scaling parameter $\alpha \geq 0$. 
	Each $F$ represents one of our forces that got defined in this chapter. 
	For the shape preserving forces, we choose $k=2$ as then the difference between current state and desired state influences the intensity of the force.
	This dynamic seems best, as small deviations from the desired state should only have a small impact, while larger deviations should be corrected more strongly. 
	But for the deforming overlap force, we choose $k=1$ as we want it to have a strong impact whenever a small overlap arises. 
	This configuration seems to be the best to model the physics we would like to achieve. 
	With that we can write down the cell wise formulated DF SDE
	\begin{align}
		\dequ C_i(t) = \F^{i}(\vec{C}(t)) \dequ t + \dequ B_i^{x}(t) \: e_{N_V}^{x} +\dequ B_i^{y}(t) \: e_{N_V}^{y}.
		\label{equ:cellwiseDFpde}
	\end{align} 
\end{definition}

\begin{figure}[]
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\textwidth]{forces/allforces_hard/t0.png} &
        \includegraphics[width=0.45\textwidth]{forces/allforces_hard/t1.png} \\
        \includegraphics[width=0.45\textwidth]{forces/allforces_hard/t2.png} &
        \includegraphics[width=0.45\textwidth]{forces/allforces_hard/t3.png} \\
    \end{tabular}
    \caption{
		This simulation shows two DF cells evolving according to the dynamics for $i = 1, 2$,
		$\frac{\partial C_i}{\partial t} = \F^i(C_1, C_2)$ with hardness $h=1$, force scalings as listed in Table~\ref{table:forcescalings} and without Brownian motion.
		Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-allForces-hard.gif}{\textit{here}} to view the corresponding animation (GIF).
		The cells are initially generated with overlap. 
		Then, the dynamics from $\F^i$ alone resolve the overlap.
		Since hardness $h=1$ was chosen, no deforming overlap force is active and the cell shape remains unchanged. 
		Consequently, the shape preserving forces are inactive, as the cells stay in their desired states.\\
		This is also reflected in the energy diagram in Figure~\ref{fig:allForces-hardEnergyDiagram}. 
	}
	\label{fig:allForces-hard}
\end{figure}



\begin{figure}[h!]
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\textwidth]{forces/allforces_0-5/t0.png} &
        \includegraphics[width=0.45\textwidth]{forces/allforces_0-5/t1.png} \\
        \includegraphics[width=0.45\textwidth]{forces/allforces_0-5/t2.png} &
        \includegraphics[width=0.45\textwidth]{forces/allforces_0-5/t3.png} \\
    \end{tabular}
    \caption{
			This simulation shows two DF cells again evolving according to the dynamics $i=1,2$, $\frac{\partial C_i}{\partial t} = \F^i(C_1, C_2)$, with hardness $h=0.5$, force scalings as listed in Table~\ref{table:forcescalings}, and without Brownian motion.
			Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-allForces-hard5e-1.gif}{\textit{here}} to view the corresponding animation (GIF).
			The cells are initially generated with overlap. 
			Afterwards, the dynamics from $\F^i$ alone resolve the overlap.
			In contrast to the previous simulation, the cell shapes now change because the deforming overlap force is active. 
			The overlap is still removed within a single time step. 
			By time step~10, the cell shapes are nearly restored, as also illustrated in Figure~\ref{fig:allForces-halfEnergyDiagram}.
			}
	\label{fig:allForces-half} 
\end{figure}




\begin{figure}[h!]
    \centering
    \begin{tabular}{cc}
        \includegraphics[width=0.45\textwidth]{forces/allforces_soft/t0.png} &
        \includegraphics[width=0.45\textwidth]{forces/allforces_soft/t1.png} \\
        \includegraphics[width=0.45\textwidth]{forces/allforces_soft/t2.png} &
        \includegraphics[width=0.45\textwidth]{forces/allforces_soft/t3.png} \\
    \end{tabular}
    \caption{This simulation shows two DF cells evolving according to the dynamics for $i=1,2$ $\frac{\partial C_i}{\partial t} = \F^i(C_1, C_2)$, with hardness $h=0$, force 		scalings as listed in Table~\ref{table:forcescalings} and without Brownian motion.
			Click \href{https://github.com/tivo476c/FlexibleCellModel/blob/master/figures/gifs/showForces/show-allForces-soft.gif}{\textit{here}} to view the corresponding animation (GIF).
			The cells are initially generated with overlap. 
			Afterwards, the dynamics from $\F^i$ alone attempt to resolve the overlap.\\
			In this case, only the deforming overlap force is active. 
			This leads to a repeating interplay: the overlap is reduced, the cell shape is restored, and this restoration again induces overlap.
			Under this setup, neither the overlap nor the desired cell shapes are fully resolved within 20 time steps, although all energy levels remain comparatively low.
			We can also see this in the energy diagram in Figure~\ref{fig:allForces-softEnergyDiagram}.
			}
	\label{fig:allForces-soft}
\end{figure}

\begin{figure}[h!]
    \centering
        \includegraphics[width=0.7\textwidth]{forces/allforces_hard/energies-show-allForces-hard1.png} 
    \caption{The bounce overlap force eliminates the overlap within a single time step.
			 The energy diagram shows that the overlap energy drops to zero immediately, while the other energies remain constant at zero as the cell shapes do not change.}
	\label{fig:allForces-hardEnergyDiagram}    
\end{figure}

\begin{figure}[h!]
    \centering
        \includegraphics[width=0.7\textwidth]{forces/allforces_0-5/energies-show-allForces-hard5e-1.png} 
    \caption{The energy diagram shows that the overlap energy drops to zero immediately, while the shape preserving energies increase initially as the cells deform to resolve the overlap.
			 By time step~10, the cell shapes are nearly restored, which is reflected in the decrease of all energies.}
	\label{fig:allForces-halfEnergyDiagram}
\end{figure}


\begin{figure}[t!]
    \centering
        \includegraphics[width=0.7\textwidth]{forces/allforces_soft/energies-show-allForces-hard0.png} 
    \caption{The energy diagram shows that the overlap energy drops initially but then increases again as the cells deform to restore their shapes.
			 This deformation again induces overlap, leading to a repeating cycle.
			 But overall, the total energy converges to a low level, indicating that the system stabilises over time.} 
	\label{fig:allForces-softEnergyDiagram}    
\end{figure}
